{"ast":null,"code":"var _jsxFileName = \"F:\\\\Final Year Project\\\\Project Implementation\\\\frontend\\\\src\\\\context\\\\WalletContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport { generateEncryptionKey } from '../utils/cryptoUtils';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WalletContext = /*#__PURE__*/createContext(undefined);\nexport const WalletProvider = ({\n  children\n}) => {\n  _s();\n  const [state, setState] = useState({\n    wallet: {\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null\n    },\n    userProfile: null,\n    isRegistered: false,\n    isLoading: false,\n    error: null\n  });\n  const [provider, setProvider] = useState(null);\n  const [signer, setSigner] = useState(null);\n  const [encryptionKey, setEncryptionKey] = useState(null);\n\n  // Initialize or get encryption key for the user\n  const initializeEncryptionKey = useCallback(account => {\n    let key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) {\n      // Generate a new encryption key if none exists\n      key = generateEncryptionKey();\n      localStorage.setItem(`encryption_key_${account}`, key);\n    }\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user\n  const getStoredFiles = useCallback(() => {\n    if (!state.wallet.account) return [];\n    const storedFiles = localStorage.getItem(`user_files_${state.wallet.account}`);\n    return storedFiles ? JSON.parse(storedFiles) : [];\n  }, [state.wallet.account]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback(() => {\n    if (!state.wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${state.wallet.account}`);\n  }, [state.wallet.account]);\n\n  // Store a new file\n  const storeFile = useCallback(file => {\n    if (!state.wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    const files = getStoredFiles();\n    // Check if file with same name already exists\n    const existingFileIndex = files.findIndex(f => f.name === file.name && f.uploadedAt === file.uploadedAt);\n    let updatedFiles;\n    if (existingFileIndex >= 0) {\n      // Update existing file\n      updatedFiles = [...files];\n      updatedFiles[existingFileIndex] = file;\n    } else {\n      // Add new file\n      updatedFiles = [...files, file];\n    }\n    localStorage.setItem(`user_files_${state.wallet.account}`, JSON.stringify(updatedFiles));\n    return updatedFiles;\n  }, [state.wallet.account, getStoredFiles]);\n\n  // Delete a file\n  const deleteStoredFile = useCallback(fileId => {\n    if (!state.wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    const files = getStoredFiles();\n    const fileToDelete = files.find(f => f.id === fileId);\n    if (!fileToDelete) {\n      throw new Error('File not found');\n    }\n    const updatedFiles = files.filter(file => file.id !== fileId);\n    localStorage.setItem(`user_files_${state.wallet.account}`, JSON.stringify(updatedFiles));\n    return updatedFiles;\n  }, [state.wallet.account, getStoredFiles]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback(() => {\n    return encryptionKey;\n  }, [encryptionKey]);\n  const checkRegistration = useCallback(async () => {\n    if (!state.wallet.account) {\n      console.log('checkRegistration: No wallet account');\n      return false;\n    }\n    try {\n      // Check if user is registered\n      const isRegistered = localStorage.getItem(`registered_${state.wallet.account}`) === 'true';\n      console.log('checkRegistration: isRegistered =', isRegistered, 'for account:', state.wallet.account);\n      if (isRegistered) {\n        // Initialize encryption key for the user\n        initializeEncryptionKey(state.wallet.account);\n\n        // Load stored user data\n        const storedUserData = localStorage.getItem(`userData_${state.wallet.account}`);\n        console.log('checkRegistration: storedUserData =', storedUserData);\n        if (storedUserData) {\n          const userProfile = JSON.parse(storedUserData);\n          setState(prev => ({\n            ...prev,\n            isRegistered,\n            userProfile\n          }));\n          console.log('checkRegistration: Loaded user profile:', userProfile);\n        } else {\n          setState(prev => ({\n            ...prev,\n            isRegistered\n          }));\n        }\n      } else {\n        console.log('checkRegistration: User not registered, setting isRegistered to false');\n        setState(prev => ({\n          ...prev,\n          isRegistered: false,\n          userProfile: null\n        }));\n      }\n      return isRegistered;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      return false;\n    }\n  }, [state.wallet.account]);\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setState({\n      wallet: {\n        isConnected: false,\n        account: null,\n        chainId: null,\n        balance: null\n      },\n      userProfile: null,\n      isRegistered: false,\n      isLoading: false,\n      error: null\n    });\n    setProvider(null);\n    setSigner(null);\n  }, []);\n  const connectWallet = useCallback(async () => {\n    if (!window.ethereum) {\n      setState(prev => ({\n        ...prev,\n        error: 'Please install MetaMask to use this application!'\n      }));\n      return;\n    }\n    try {\n      setState(prev => ({\n        ...prev,\n        isLoading: true,\n        error: null\n      }));\n\n      // Request account access\n      const accounts = await window.ethereum.request({\n        method: 'eth_requestAccounts'\n      });\n      const account = accounts[0];\n\n      // Get the current network\n      const newProvider = new ethers.BrowserProvider(window.ethereum);\n      const network = await newProvider.getNetwork();\n      const balance = await newProvider.getBalance(account);\n      const newSigner = await newProvider.getSigner();\n      setProvider(newProvider);\n      setSigner(newSigner);\n\n      // Initialize encryption key for the user\n      initializeEncryptionKey(account);\n\n      // Update state\n      setState(prev => ({\n        ...prev,\n        wallet: {\n          isConnected: true,\n          account,\n          chainId: network.chainId.toString(),\n          balance: ethers.formatEther(balance)\n        },\n        isLoading: false\n      }));\n\n      // Check if user is registered\n      await checkRegistration();\n    } catch (error) {\n      console.error('Error connecting wallet:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Failed to connect wallet. Please try again.'\n      }));\n    }\n  }, [checkRegistration, initializeEncryptionKey]);\n  const handleAccountsChanged = useCallback(accounts => {\n    if (accounts.length === 0) {\n      disconnectWallet();\n    } else {\n      connectWallet();\n    }\n  }, [connectWallet, disconnectWallet]);\n  const clearUserData = useCallback(() => {\n    if (state.wallet.account) {\n      localStorage.removeItem(`user_${state.wallet.account}`);\n      // Don't remove the encryption key or files on logout\n      // This allows users to access their files when they log back in\n    }\n    setState(prev => ({\n      ...prev,\n      isRegistered: false,\n      userProfile: null,\n      error: null\n    }));\n  }, [state.wallet.account]);\n  const registerUser = useCallback(async (username, email) => {\n    console.log('registerUser called with:', {\n      username,\n      email,\n      account: state.wallet.account\n    });\n    if (!provider || !signer || !state.wallet.account) {\n      console.error('registerUser: Wallet not connected', {\n        provider: !!provider,\n        signer: !!signer,\n        account: state.wallet.account\n      });\n      throw new Error('Wallet not connected');\n    }\n    try {\n      setState(prev => ({\n        ...prev,\n        isLoading: true,\n        error: null\n      }));\n      const userProfile = {\n        username,\n        email,\n        walletAddress: state.wallet.account,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n\n      // Update state\n      setState(prev => ({\n        ...prev,\n        isRegistered: true,\n        userProfile,\n        isLoading: false,\n        error: null\n      }));\n\n      // Save to localStorage\n      localStorage.setItem(`user_${state.wallet.account}`, JSON.stringify(userProfile));\n\n      // Generate and store encryption key if it doesn't exist\n      if (!localStorage.getItem(`encryption_key_${state.wallet.account}`)) {\n        const key = generateEncryptionKey();\n        localStorage.setItem(`encryption_key_${state.wallet.account}`, key);\n\n        // In a real app, you would show this to the user and ask them to save it\n        alert(`IMPORTANT: Your encryption key is: ${key}\\n\\nPlease save this key in a secure place. You will need it to access your files.`);\n      }\n      return true;\n    } catch (error) {\n      console.error('Registration failed:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Failed to register user. Please try again.'\n      }));\n      return false;\n    }\n  }, [provider, signer, state.wallet.account]);\n  const value = {\n    state,\n    connectWallet,\n    disconnectWallet,\n    checkRegistration,\n    registerUser,\n    clearUserData,\n    getEncryptionKey: getEncryptionKeyFromState,\n    getStoredFiles,\n    storeFile,\n    deleteStoredFile: deleteStoredFile,\n    getEncryptionKeyFromState\n  };\n  return /*#__PURE__*/_jsxDEV(WalletContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 337,\n    columnNumber: 5\n  }, this);\n};\n_s(WalletProvider, \"P1czdN3qqQZG8KZ6LjQP59abc2o=\");\n_c = WalletProvider;\nexport const useWallet = () => {\n  _s2();\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\n_s2(useWallet, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"WalletProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","ethers","generateEncryptionKey","jsxDEV","_jsxDEV","WalletContext","undefined","WalletProvider","children","_s","state","setState","wallet","isConnected","account","chainId","balance","userProfile","isRegistered","isLoading","error","provider","setProvider","signer","setSigner","encryptionKey","setEncryptionKey","initializeEncryptionKey","key","localStorage","getItem","setItem","getStoredFiles","storedFiles","JSON","parse","getEncryptionKey","storeFile","file","Error","files","existingFileIndex","findIndex","f","name","uploadedAt","updatedFiles","stringify","deleteStoredFile","fileId","fileToDelete","find","id","filter","getEncryptionKeyFromState","checkRegistration","console","log","storedUserData","prev","disconnectWallet","connectWallet","window","ethereum","accounts","request","method","newProvider","BrowserProvider","network","getNetwork","getBalance","newSigner","getSigner","toString","formatEther","handleAccountsChanged","length","clearUserData","removeItem","registerUser","username","email","walletAddress","registrationTime","Date","toISOString","isActive","reputationScore","accessRoles","alert","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useWallet","_s2","context","$RefreshReg$"],"sources":["F:/Final Year Project/Project Implementation/frontend/src/context/WalletContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';\nimport { ethers } from 'ethers';\nimport { StoredFile } from '../components/files/FileList';\nimport { AppState, UserProfile } from '../types';\nimport { generateEncryptionKey } from '../utils/cryptoUtils';\n\ninterface WalletContextType {\n  state: AppState;\n  connectWallet: () => Promise<void>;\n  disconnectWallet: () => void;\n  checkRegistration: () => Promise<boolean>;\n  registerUser: (username: string, email: string) => Promise<boolean>;\n  clearUserData: () => void;\n  getEncryptionKey: () => string | null;\n  getStoredFiles: () => StoredFile[];\n  storeFile: (file: StoredFile) => StoredFile[] | undefined;\n  deleteStoredFile: (fileId: string) => StoredFile[];\n  getEncryptionKeyFromState: () => string | null;\n}\n\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\n\ninterface WalletProviderProps {\n  children: ReactNode;\n}\n\nexport const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {\n  const [state, setState] = useState<AppState>({\n    wallet: {\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null,\n    },\n    userProfile: null,\n    isRegistered: false,\n    isLoading: false,\n    error: null,\n  });\n\n  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);\n  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);\n  const [encryptionKey, setEncryptionKey] = useState<string | null>(null);\n\n  // Initialize or get encryption key for the user\n  const initializeEncryptionKey = useCallback((account: string) => {\n    let key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) {\n      // Generate a new encryption key if none exists\n      key = generateEncryptionKey();\n      localStorage.setItem(`encryption_key_${account}`, key);\n    }\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user\n  const getStoredFiles = useCallback((): StoredFile[] => {\n    if (!state.wallet.account) return [];\n    const storedFiles = localStorage.getItem(`user_files_${state.wallet.account}`);\n    return storedFiles ? JSON.parse(storedFiles) : [];\n  }, [state.wallet.account]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback((): string | null => {\n    if (!state.wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${state.wallet.account}`);\n  }, [state.wallet.account]);\n\n  // Store a new file\n  const storeFile = useCallback((file: StoredFile) => {\n    if (!state.wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    // Check if file with same name already exists\n    const existingFileIndex = files.findIndex(f => f.name === file.name && f.uploadedAt === file.uploadedAt);\n    \n    let updatedFiles;\n    if (existingFileIndex >= 0) {\n      // Update existing file\n      updatedFiles = [...files];\n      updatedFiles[existingFileIndex] = file;\n    } else {\n      // Add new file\n      updatedFiles = [...files, file];\n    }\n    \n    localStorage.setItem(\n      `user_files_${state.wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [state.wallet.account, getStoredFiles]);\n\n  // Delete a file\n  const deleteStoredFile = useCallback((fileId: string) => {\n    if (!state.wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    const fileToDelete = files.find(f => f.id === fileId);\n    \n    if (!fileToDelete) {\n      throw new Error('File not found');\n    }\n    \n    const updatedFiles = files.filter(file => file.id !== fileId);\n    \n    localStorage.setItem(\n      `user_files_${state.wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [state.wallet.account, getStoredFiles]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback((): string | null => {\n    return encryptionKey;\n  }, [encryptionKey]);\n\n  const checkRegistration = useCallback(async (): Promise<boolean> => {\n    if (!state.wallet.account) {\n      console.log('checkRegistration: No wallet account');\n      return false;\n    }\n\n    try {\n      // Check if user is registered\n      const isRegistered = localStorage.getItem(`registered_${state.wallet.account}`) === 'true';\n      console.log('checkRegistration: isRegistered =', isRegistered, 'for account:', state.wallet.account);\n      \n      if (isRegistered) {\n        // Initialize encryption key for the user\n        initializeEncryptionKey(state.wallet.account);\n        \n        // Load stored user data\n        const storedUserData = localStorage.getItem(`userData_${state.wallet.account}`);\n        console.log('checkRegistration: storedUserData =', storedUserData);\n        if (storedUserData) {\n          const userProfile: UserProfile = JSON.parse(storedUserData);\n          setState(prev => ({\n            ...prev,\n            isRegistered,\n            userProfile,\n          }));\n          console.log('checkRegistration: Loaded user profile:', userProfile);\n        } else {\n          setState(prev => ({\n            ...prev,\n            isRegistered,\n          }));\n        }\n      } else {\n        console.log('checkRegistration: User not registered, setting isRegistered to false');\n        setState(prev => ({\n          ...prev,\n          isRegistered: false,\n          userProfile: null,\n        }));\n      }\n\n      return isRegistered;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      return false;\n    }\n  }, [state.wallet.account]);\n\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setState({\n      wallet: {\n        isConnected: false,\n        account: null,\n        chainId: null,\n        balance: null,\n      },\n      userProfile: null,\n      isRegistered: false,\n      isLoading: false,\n      error: null,\n    });\n    setProvider(null);\n    setSigner(null);\n  }, []);\n\n  const connectWallet = useCallback(async () => {\n    if (!window.ethereum) {\n      setState(prev => ({\n        ...prev,\n        error: 'Please install MetaMask to use this application!'\n      }));\n      return;\n    }\n\n    try {\n      setState(prev => ({ ...prev, isLoading: true, error: null }));\n\n      // Request account access\n      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });\n      const account = accounts[0];\n\n      // Get the current network\n      const newProvider = new ethers.BrowserProvider(window.ethereum);\n      const network = await newProvider.getNetwork();\n      const balance = await newProvider.getBalance(account);\n      const newSigner = await newProvider.getSigner();\n\n      setProvider(newProvider);\n      setSigner(newSigner);\n\n      // Initialize encryption key for the user\n      initializeEncryptionKey(account);\n\n      // Update state\n      setState(prev => ({\n        ...prev,\n        wallet: {\n          isConnected: true,\n          account,\n          chainId: network.chainId.toString(),\n          balance: ethers.formatEther(balance)\n        },\n        isLoading: false\n      }));\n\n      // Check if user is registered\n      await checkRegistration();\n\n    } catch (error) {\n      console.error('Error connecting wallet:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Failed to connect wallet. Please try again.'\n      }));\n    }\n  }, [checkRegistration, initializeEncryptionKey]);\n\n  const handleAccountsChanged = useCallback((accounts: string[]) => {\n    if (accounts.length === 0) {\n      disconnectWallet();\n    } else {\n      connectWallet();\n    }\n  }, [connectWallet, disconnectWallet]);\n\n  const clearUserData = useCallback(() => {\n    if (state.wallet.account) {\n      localStorage.removeItem(`user_${state.wallet.account}`);\n      // Don't remove the encryption key or files on logout\n      // This allows users to access their files when they log back in\n    }\n    \n    setState(prev => ({\n      ...prev,\n      isRegistered: false,\n      userProfile: null,\n      error: null\n    }));\n  }, [state.wallet.account]);\n\n  const registerUser = useCallback(async (username: string, email: string): Promise<boolean> => {\n    console.log('registerUser called with:', { username, email, account: state.wallet.account });\n    \n    if (!provider || !signer || !state.wallet.account) {\n      console.error('registerUser: Wallet not connected', { provider: !!provider, signer: !!signer, account: state.wallet.account });\n      throw new Error('Wallet not connected');\n    }\n\n    try {\n      setState(prev => ({ ...prev, isLoading: true, error: null }));\n\n      const userProfile: UserProfile = {\n        username,\n        email,\n        walletAddress: state.wallet.account,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n      \n      // Update state\n      setState(prev => ({\n        ...prev,\n        isRegistered: true,\n        userProfile,\n        isLoading: false,\n        error: null,\n      }));\n      \n      // Save to localStorage\n      localStorage.setItem(`user_${state.wallet.account}`, JSON.stringify(userProfile));\n      \n      // Generate and store encryption key if it doesn't exist\n      if (!localStorage.getItem(`encryption_key_${state.wallet.account}`)) {\n        const key = generateEncryptionKey();\n        localStorage.setItem(`encryption_key_${state.wallet.account}`, key);\n        \n        // In a real app, you would show this to the user and ask them to save it\n        alert(`IMPORTANT: Your encryption key is: ${key}\\n\\nPlease save this key in a secure place. You will need it to access your files.`);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Registration failed:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Failed to register user. Please try again.'\n      }));\n      return false;\n    }\n  }, [provider, signer, state.wallet.account]);\n\n  const value: WalletContextType = {\n    state,\n    connectWallet,\n    disconnectWallet,\n    checkRegistration,\n    registerUser,\n    clearUserData,\n    getEncryptionKey: getEncryptionKeyFromState,\n    getStoredFiles,\n    storeFile,\n    deleteStoredFile: deleteStoredFile as (fileId: string) => StoredFile[],\n    getEncryptionKeyFromState,\n  };\n\n  return (\n    <WalletContext.Provider value={value}>\n      {children}\n    </WalletContext.Provider>\n  );\n};\n\nexport const useWallet = (): WalletContextType => {\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}