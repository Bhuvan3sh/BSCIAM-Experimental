{"ast":null,"code":"import _objectSpread from\"F:/Final Year Project/Project Implementation/BSCIAM-Experimental/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useState,useCallback}from'react';import{ethers}from'ethers';import{BSCIAMAuthABI}from'../config/abi';import contracts from'../config/contracts.json';import{fileApi}from'../services/fileApi';import{jsx as _jsx}from\"react/jsx-runtime\";const WalletContext=/*#__PURE__*/createContext(undefined);export const WalletProvider=_ref=>{let{children}=_ref;const[wallet,setWallet]=useState({isConnected:false,account:null,chainId:null,balance:null});const[userProfile,setUserProfile]=useState(null);const[isRegistered,setIsRegistered]=useState(false);const[isLoading,setIsLoading]=useState(false);const[error,setError]=useState(null);const[encryptionKey,setEncryptionKey]=useState(null);const[provider,setProvider]=useState(null);const[signer,setSigner]=useState(null);// Initialize encryption key for the current account\nconst initializeEncryptionKey=useCallback(account=>{const key=localStorage.getItem(\"encryption_key_\".concat(account));if(!key)return null;setEncryptionKey(key);return key;},[]);// Get stored files for the current user (from server)\nconst getStoredFiles=useCallback(async()=>{if(!wallet.account)return[];try{const files=await fileApi.getFiles(wallet.account);return files;}catch(error){console.error('Error fetching files from server:',error);return[];}},[wallet.account]);// Activity helpers\nconst getActivities=useCallback(()=>{if(!wallet.account)return[];const raw=localStorage.getItem(\"activities_\".concat(wallet.account));return raw?JSON.parse(raw):[];},[wallet.account]);const saveActivities=useCallback(activities=>{if(!wallet.account)return;localStorage.setItem(\"activities_\".concat(wallet.account),JSON.stringify(activities));},[wallet.account]);const bumpReputation=useCallback(()=>{if(!wallet.account)return;const userRaw=localStorage.getItem(\"user_\".concat(wallet.account));if(!userRaw)return;const updated=_objectSpread(_objectSpread({},JSON.parse(userRaw)),{},{reputationScore:(JSON.parse(userRaw).reputationScore||0)+10});localStorage.setItem(\"user_\".concat(wallet.account),JSON.stringify(updated));setUserProfile(updated);},[wallet.account]);const recordActivity=useCallback((type,details)=>{if(!wallet.account)return;const activities=getActivities();const entry={id:crypto.randomUUID(),type,details,timestamp:new Date().toISOString()};const updated=[entry,...activities].slice(0,100);saveActivities(updated);bumpReputation();},[wallet.account,getActivities,saveActivities,bumpReputation]);// Get the user's encryption key\nconst getEncryptionKey=useCallback(()=>{if(!wallet.account)return null;return localStorage.getItem(\"encryption_key_\".concat(wallet.account));},[wallet.account]);// Store a new file (uploads to server)\nconst storeFile=useCallback(async file=>{if(!wallet.account){throw new Error('No wallet connected');}if(!file.encryptedData){throw new Error('File must have encrypted data to store');}try{// Upload to server\nawait fileApi.uploadFile({fileId:file.id,encryptedData:file.encryptedData,metadata:file.metadata,walletAddress:wallet.account});// Fetch updated list from server\nconst updatedFiles=await getStoredFiles();// Record upload activity\ntry{recordActivity('upload',file.name);}catch(_unused){}return updatedFiles;}catch(error){console.error('Error storing file:',error);throw error;}},[wallet.account,getStoredFiles,recordActivity]);// Delete a file (from server)\nconst deleteStoredFile=useCallback(async fileId=>{if(!wallet.account){throw new Error('No wallet connected');}try{// Get file info before deletion for activity log\nconst files=await getStoredFiles();const fileToDelete=files.find(f=>f.id===fileId);// Delete from server\nawait fileApi.deleteFile(fileId,wallet.account);// Record activity\ntry{recordActivity('delete',(fileToDelete===null||fileToDelete===void 0?void 0:fileToDelete.name)||'unknown');}catch(_unused2){}}catch(error){console.error('Error deleting file:',error);throw error;}},[wallet.account,getStoredFiles,recordActivity]);// Modify (replace) an existing file (on server)\nconst modifyFile=useCallback(async(fileId,file,encryptedData,key)=>{if(!wallet.account){throw new Error('No wallet connected');}if(!key){throw new Error('Encryption key is required');}if(!encryptedData){throw new Error('No encrypted data provided');}try{setIsLoading(true);const files=await getStoredFiles();const existingFile=files.find(f=>f.id===fileId);if(!existingFile){throw new Error('File not found');}// Validate that the new file has the same name and type\nif(file.name!==existingFile.name){throw new Error(\"File name must match. Expected: \".concat(existingFile.name,\", Got: \").concat(file.name));}if(file.type!==existingFile.type){throw new Error(\"File type must match. Expected: \".concat(existingFile.type,\", Got: \").concat(file.type));}// Create updated file object with same ID but new data\nconst updatedFile={id:existingFile.id,// Keep the same ID\nname:file.name,type:file.type,size:file.size,uploadedAt:new Date().toISOString(),// Update to current time to reflect modification\nencryptedData:'',// Empty - actual data stored on server\nmetadata:{name:file.name,originalName:file.name,type:file.type,mimeType:file.type,size:file.size,lastModified:file.lastModified}};// Update encrypted data on server\nawait fileApi.updateFile(fileId,encryptedData.encryptedData||encryptedData,updatedFile.metadata,wallet.account);try{recordActivity('upload',\"Modified: \".concat(file.name));}catch(_unused3){}return updatedFile;}catch(error){console.error('Error modifying file:',error);throw error;}finally{setIsLoading(false);}},[wallet.account,getStoredFiles,recordActivity]);// Get the current encryption key\nconst getEncryptionKeyFromState=useCallback(()=>{return encryptionKey;},[encryptionKey]);// Upload a file with encryption (to server)\nconst uploadFile=useCallback(async(file,encryptedData,key)=>{if(!wallet.account){throw new Error('No wallet connected');}if(!key){throw new Error('Encryption key is required');}if(!encryptedData){throw new Error('No encrypted data provided');}try{setIsLoading(true);const storedFiles=await getStoredFiles();// Check if file with same name already exists\nconst fileExists=storedFiles.some(f=>{var _f$metadata;return f.name===file.name&&((_f$metadata=f.metadata)===null||_f$metadata===void 0?void 0:_f$metadata.lastModified)===file.lastModified;});if(fileExists){throw new Error('A file with this name already exists');}const newFile={id:crypto.randomUUID(),name:file.name,type:file.type,size:file.size,uploadedAt:new Date().toISOString(),encryptedData:'',// Empty - actual data stored on server\nmetadata:{name:file.name,originalName:file.name,type:file.type,mimeType:file.type,size:file.size,lastModified:file.lastModified}};// Upload encrypted data to server\nawait fileApi.uploadFile({fileId:newFile.id,encryptedData:encryptedData.encryptedData||encryptedData,metadata:newFile.metadata,walletAddress:wallet.account});return newFile;}catch(error){console.error('Error uploading file:',error);throw error;}finally{setIsLoading(false);}},[wallet.account,getStoredFiles]);// Check if user is already registered\nconst checkRegistration=useCallback(async account=>{try{if(!account)return false;const userData=localStorage.getItem(\"user_\".concat(account));const encryptionKey=localStorage.getItem(\"encryption_key_\".concat(account));if(userData&&encryptionKey){const userProfile=JSON.parse(userData);setUserProfile(userProfile);setEncryptionKey(encryptionKey);setIsRegistered(true);return true;}// Clear any partial data if registration is not complete\nlocalStorage.removeItem(\"user_\".concat(account));localStorage.removeItem(\"encryption_key_\".concat(account));return false;}catch(error){console.error('Error checking registration:',error);setError('Failed to check user registration.');return false;}},[initializeEncryptionKey]);// Validate encryption key against the stored key\nconst validateEncryptionKey=useCallback(key=>{if(!wallet.account)return false;const storedKey=localStorage.getItem(\"encryption_key_\".concat(wallet.account));return key===storedKey;},[wallet.account]);// Disconnect wallet\nconst disconnectWallet=useCallback(()=>{// Note: We don't clear localStorage here to preserve user data for future logins\nsetWallet({isConnected:false,account:null,chainId:null,balance:null});setUserProfile(null);setIsRegistered(false);setIsLoading(false);setError(null);setProvider(null);setSigner(null);},[]);// Connect wallet\nconst connectWallet=useCallback(async()=>{if(typeof window.ethereum==='undefined'){setError('Please install MetaMask!');return;}try{setIsLoading(true);const provider=new ethers.BrowserProvider(window.ethereum);const signer=await provider.getSigner();const address=await signer.getAddress();const network=await provider.getNetwork();setProvider(provider);setSigner(signer);setWallet({isConnected:true,account:address,chainId:network.chainId.toString(),balance:null});setError(null);// Check if user is registered\nconst registered=await checkRegistration(address);if(registered){try{recordActivity('login','Wallet connected');}catch(_unused4){}}}catch(err){console.error('Error connecting wallet:',err);setError('Failed to connect wallet. Please try again.');}finally{setIsLoading(false);}},[checkRegistration]);// Register a new user\nconst registerUser=useCallback(async function(username){let email=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';if(!wallet.account){return{success:false,message:'No wallet connected'};}try{setIsLoading(true);// Generate a secure encryption key for the user\nconst key=Array.from(window.crypto.getRandomValues(new Uint8Array(32))).map(b=>b.toString(16).padStart(2,'0')).join('');// Create user profile according to UserProfile interface\nconst newUserProfile={walletAddress:wallet.account,username,email,registrationTime:new Date().toISOString(),isActive:true,reputationScore:0,accessRoles:['user']};// Store user data and encryption key in localStorage\nlocalStorage.setItem(\"user_\".concat(wallet.account),JSON.stringify(newUserProfile));localStorage.setItem(\"encryption_key_\".concat(wallet.account),key);// Update state\nsetUserProfile(newUserProfile);setIsRegistered(true);setEncryptionKey(key);// Seed activities with registration considered as login\ntry{const initialActivities=[{id:crypto.randomUUID(),type:'login',details:'Registered and logged in',timestamp:new Date().toISOString()}];localStorage.setItem(\"activities_\".concat(wallet.account),JSON.stringify(initialActivities));}catch(_unused5){}// Copy the encryption key to clipboard\ntry{await navigator.clipboard.writeText(key);// Also alert the user with the generated key\ntry{window.alert(\"Registration successful!\\n\\nYour encryption key (copy kept in clipboard):\\n\".concat(key,\"\\n\\nStore this key safely; it is required for all file operations.\"));}catch(e){// no-op if alert blocked\n}return{success:true,message:'Registration successful! Your encryption key has been copied to clipboard. Please keep it safe!',encryptionKey:key};}catch(clipboardError){console.error('Failed to copy encryption key:',clipboardError);try{window.alert(\"Registration successful!\\n\\nPlease copy and save your encryption key:\\n\".concat(key));}catch(e){// no-op\n}return{success:true,message:\"Registration successful! Please copy and save your encryption key: \".concat(key),encryptionKey:key};}}catch(error){console.error('Registration failed:',error);return{success:false,message:error instanceof Error?error.message:'Registration failed. Please try again.'};}finally{setIsLoading(false);}},[wallet.account]);const updateUsername=useCallback(newUsername=>{if(!wallet.account||!userProfile)return;const updated=_objectSpread(_objectSpread({},userProfile),{},{username:newUsername});localStorage.setItem(\"user_\".concat(wallet.account),JSON.stringify(updated));setUserProfile(updated);},[wallet.account,userProfile]);const getRecentActivities=useCallback(function(){let limit=arguments.length>0&&arguments[0]!==undefined?arguments[0]:3;return getActivities().slice(0,limit);},[getActivities]);const getAllActivities=useCallback(()=>{return getActivities();},[getActivities]);const getAllUsers=useCallback(async()=>{const users=[];// Local users (same browser)\nfor(let i=0;i<localStorage.length;i++){const key=localStorage.key(i);if(!key)continue;if(key.startsWith('user_')){try{const parsed=JSON.parse(localStorage.getItem(key)||'null');if(parsed&&parsed.walletAddress)users.push(parsed);}catch(_unused6){}}}// Attempt to augment with on-chain users if connected and configured\ntry{var _contracts$auth;if(provider&&contracts!==null&&contracts!==void 0&&(_contracts$auth=contracts.auth)!==null&&_contracts$auth!==void 0&&_contracts$auth.address){// Heuristic: scan recent UserRegistered events for a small block window\nconst ethProvider=provider;const signer=await ethProvider.getSigner();const contract=new ethers.Contract(contracts.auth.address,BSCIAMAuthABI,signer);const currentBlock=await ethProvider.getBlockNumber();const fromBlock=currentBlock-5000>0?currentBlock-5000:0;// last ~5000 blocks\n// v6 queryFilter across fragments requires passing event name\nconst events=await contract.queryFilter('UserRegistered',fromBlock,currentBlock);for(const ev of events){const args=ev.args;const user=(args===null||args===void 0?void 0:args.user)||(args===null||args===void 0?void 0:args[0]);if(!user)continue;try{const p=await contract.getUserProfile(user);const profile={walletAddress:p.walletAddress,username:p.username,email:p.email,registrationTime:new Date(Number(p.registrationTime)*1000).toISOString(),isActive:Boolean(p.isActive),reputationScore:Number(p.reputationScore),accessRoles:Array.from(p.accessRoles||[])};if(!users.find(u=>u.walletAddress.toLowerCase()===profile.walletAddress.toLowerCase())){users.push(profile);}}catch(_unused7){}}}}catch(e){console.warn('On-chain user fetch skipped or failed:',e);}return users;},[provider]);const value={wallet,isRegistered,userProfile,isLoading,error,encryptionKey,connectWallet,disconnectWallet,registerUser,getEncryptionKey:getEncryptionKeyFromState,validateEncryptionKey,getStoredFiles,storeFile,uploadFile,downloadFile:async(fileId,key)=>{console.log('Downloading file:',fileId,'with key:',key);const files=await getStoredFiles();const file=files.find(f=>f.id===fileId);if(!file)throw new Error('File not found');// Encrypted data is fetched in FileList component via API\n// This method is kept for interface compatibility\nreturn;},deleteStoredFile,modifyFile,getRecentActivities,getAllActivities,recordActivity,updateUsername,getAllUsers};return/*#__PURE__*/_jsx(WalletContext.Provider,{value:value,children:children});};export const useWallet=()=>{const context=useContext(WalletContext);if(context===undefined){throw new Error('useWallet must be used within a WalletProvider');}return context;};// Extend Window interface for TypeScript","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","ethers","BSCIAMAuthABI","contracts","fileApi","jsx","_jsx","WalletContext","undefined","WalletProvider","_ref","children","wallet","setWallet","isConnected","account","chainId","balance","userProfile","setUserProfile","isRegistered","setIsRegistered","isLoading","setIsLoading","error","setError","encryptionKey","setEncryptionKey","provider","setProvider","signer","setSigner","initializeEncryptionKey","key","localStorage","getItem","concat","getStoredFiles","files","getFiles","console","getActivities","raw","JSON","parse","saveActivities","activities","setItem","stringify","bumpReputation","userRaw","updated","_objectSpread","reputationScore","recordActivity","type","details","entry","id","crypto","randomUUID","timestamp","Date","toISOString","slice","getEncryptionKey","storeFile","file","Error","encryptedData","uploadFile","fileId","metadata","walletAddress","updatedFiles","name","_unused","deleteStoredFile","fileToDelete","find","f","deleteFile","_unused2","modifyFile","existingFile","updatedFile","size","uploadedAt","originalName","mimeType","lastModified","updateFile","_unused3","getEncryptionKeyFromState","storedFiles","fileExists","some","_f$metadata","newFile","checkRegistration","userData","removeItem","validateEncryptionKey","storedKey","disconnectWallet","connectWallet","window","ethereum","BrowserProvider","getSigner","address","getAddress","network","getNetwork","toString","registered","_unused4","err","registerUser","username","email","arguments","length","success","message","Array","from","getRandomValues","Uint8Array","map","b","padStart","join","newUserProfile","registrationTime","isActive","accessRoles","initialActivities","_unused5","navigator","clipboard","writeText","alert","e","clipboardError","updateUsername","newUsername","getRecentActivities","limit","getAllActivities","getAllUsers","users","i","startsWith","parsed","push","_unused6","_contracts$auth","auth","ethProvider","contract","Contract","currentBlock","getBlockNumber","fromBlock","events","queryFilter","ev","args","user","p","getUserProfile","profile","Number","Boolean","u","toLowerCase","_unused7","warn","value","downloadFile","log","Provider","useWallet","context"],"sources":["F:/Final Year Project/Project Implementation/BSCIAM-Experimental/frontend/src/context/WalletContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';\nimport { ethers } from 'ethers';\nimport { BSCIAMAuthABI } from '../config/abi';\nimport contracts from '../config/contracts.json';\nimport { StoredFile } from '../types';\nimport { UserProfile } from '../types';\nimport { fileApi } from '../services/fileApi';\n\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n\ninterface WalletState {\n  isConnected: boolean;\n  account: string | null;\n  chainId: string | null;\n  balance: string | null;\n}\n\ninterface WalletContextType {\n  // Wallet state\n  wallet: WalletState;\n  isRegistered: boolean;\n  userProfile: UserProfile | null;\n  isLoading: boolean;\n  error: string | null;\n  encryptionKey: string | null;\n  \n  // Wallet methods\n  connectWallet: () => Promise<void>;\n  disconnectWallet: () => void;\n  \n  // User methods\n  registerUser: (username: string, email?: string) => Promise<{ \n    success: boolean; \n    message: string; \n    encryptionKey?: string \n  }>;\n  \n  // Encryption methods\n  getEncryptionKey: () => string | null;\n  validateEncryptionKey: (key: string) => boolean;\n  \n  // File methods\n  getStoredFiles: () => Promise<StoredFile[]>;\n  storeFile: (file: StoredFile) => Promise<StoredFile[]>;\n  uploadFile: (file: File, encryptedData: any, key: string) => Promise<StoredFile>;\n  downloadFile: (fileId: string, key: string) => Promise<void>;\n  deleteStoredFile: (fileId: string) => Promise<void>;\n  modifyFile: (fileId: string, file: File, encryptedData: any, key: string) => Promise<StoredFile>;\n\n  // Activity & profile\n  getRecentActivities: (limit?: number) => Array<{ id: string; type: string; details?: string; timestamp: string }>;\n  getAllActivities: () => Array<{ id: string; type: string; details?: string; timestamp: string }>;\n  recordActivity: (type: 'login' | 'upload' | 'download' | 'delete', details?: string) => void;\n  updateUsername: (newUsername: string) => void;\n  getAllUsers: () => Promise<UserProfile[]>;\n}\n\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\n\ninterface WalletProviderProps {\n  children: ReactNode;\n}\n\nexport const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {\n  const [wallet, setWallet] = useState<WalletState>({\n    isConnected: false,\n    account: null,\n    chainId: null,\n    balance: null,\n  });\n  \n  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);\n  const [isRegistered, setIsRegistered] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [encryptionKey, setEncryptionKey] = useState<string | null>(null);\n\n  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);\n  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);\n\n  // Initialize encryption key for the current account\n  const initializeEncryptionKey = useCallback((account: string): string | null => {\n    const key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) return null;\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user (from server)\n  const getStoredFiles = useCallback(async (): Promise<StoredFile[]> => {\n    if (!wallet.account) return [];\n    try {\n      const files = await fileApi.getFiles(wallet.account);\n      return files;\n    } catch (error) {\n      console.error('Error fetching files from server:', error);\n      return [];\n    }\n  }, [wallet.account]);\n\n  // Activity helpers\n  const getActivities = useCallback((): Array<{ id: string; type: string; details?: string; timestamp: string }> => {\n    if (!wallet.account) return [];\n    const raw = localStorage.getItem(`activities_${wallet.account}`);\n    return raw ? JSON.parse(raw) : [];\n  }, [wallet.account]);\n\n  const saveActivities = useCallback((activities: Array<{ id: string; type: string; details?: string; timestamp: string }>) => {\n    if (!wallet.account) return;\n    localStorage.setItem(`activities_${wallet.account}`, JSON.stringify(activities));\n  }, [wallet.account]);\n\n  const bumpReputation = useCallback(() => {\n    if (!wallet.account) return;\n    const userRaw = localStorage.getItem(`user_${wallet.account}`);\n    if (!userRaw) return;\n    const updated: UserProfile = { ...JSON.parse(userRaw), reputationScore: (JSON.parse(userRaw).reputationScore || 0) + 10 };\n    localStorage.setItem(`user_${wallet.account}`, JSON.stringify(updated));\n    setUserProfile(updated);\n  }, [wallet.account]);\n\n  const recordActivity = useCallback((type: 'login' | 'upload' | 'download' | 'delete', details?: string) => {\n    if (!wallet.account) return;\n    const activities = getActivities();\n    const entry = { id: crypto.randomUUID(), type, details, timestamp: new Date().toISOString() };\n    const updated = [entry, ...activities].slice(0, 100);\n    saveActivities(updated);\n    bumpReputation();\n  }, [wallet.account, getActivities, saveActivities, bumpReputation]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback((): string | null => {\n    if (!wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${wallet.account}`);\n  }, [wallet.account]);\n\n  // Store a new file (uploads to server)\n  const storeFile = useCallback(async (file: StoredFile): Promise<StoredFile[]> => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    if (!file.encryptedData) {\n      throw new Error('File must have encrypted data to store');\n    }\n    \n    try {\n      // Upload to server\n      await fileApi.uploadFile({\n        fileId: file.id,\n        encryptedData: file.encryptedData,\n        metadata: file.metadata,\n        walletAddress: wallet.account,\n      });\n      \n      // Fetch updated list from server\n      const updatedFiles = await getStoredFiles();\n      \n      // Record upload activity\n      try { recordActivity('upload', file.name); } catch {}\n      \n      return updatedFiles;\n    } catch (error) {\n      console.error('Error storing file:', error);\n      throw error;\n    }\n  }, [wallet.account, getStoredFiles, recordActivity]);\n\n  // Delete a file (from server)\n  const deleteStoredFile = useCallback(async (fileId: string): Promise<void> => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    try {\n      // Get file info before deletion for activity log\n      const files = await getStoredFiles();\n      const fileToDelete = files.find(f => f.id === fileId);\n      \n      // Delete from server\n      await fileApi.deleteFile(fileId, wallet.account);\n      \n      // Record activity\n      try { recordActivity('delete', fileToDelete?.name || 'unknown'); } catch {}\n    } catch (error) {\n      console.error('Error deleting file:', error);\n      throw error;\n    }\n  }, [wallet.account, getStoredFiles, recordActivity]);\n\n  // Modify (replace) an existing file (on server)\n  const modifyFile = useCallback(async (fileId: string, file: File, encryptedData: any, key: string): Promise<StoredFile> => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    if (!key) {\n      throw new Error('Encryption key is required');\n    }\n    \n    if (!encryptedData) {\n      throw new Error('No encrypted data provided');\n    }\n    \n    try {\n      setIsLoading(true);\n      const files = await getStoredFiles();\n      const existingFile = files.find(f => f.id === fileId);\n      \n      if (!existingFile) {\n        throw new Error('File not found');\n      }\n      \n      // Validate that the new file has the same name and type\n      if (file.name !== existingFile.name) {\n        throw new Error(`File name must match. Expected: ${existingFile.name}, Got: ${file.name}`);\n      }\n      \n      if (file.type !== existingFile.type) {\n        throw new Error(`File type must match. Expected: ${existingFile.type}, Got: ${file.type}`);\n      }\n      \n      // Create updated file object with same ID but new data\n      const updatedFile: StoredFile = {\n        id: existingFile.id, // Keep the same ID\n        name: file.name,\n        type: file.type,\n        size: file.size,\n        uploadedAt: new Date().toISOString(), // Update to current time to reflect modification\n        encryptedData: '', // Empty - actual data stored on server\n        metadata: {\n          name: file.name,\n          originalName: file.name,\n          type: file.type,\n          mimeType: file.type,\n          size: file.size,\n          lastModified: file.lastModified\n        }\n      };\n      \n      // Update encrypted data on server\n      await fileApi.updateFile(\n        fileId,\n        encryptedData.encryptedData || encryptedData,\n        updatedFile.metadata,\n        wallet.account\n      );\n      \n      try { recordActivity('upload', `Modified: ${file.name}`); } catch {}\n      \n      return updatedFile;\n    } catch (error) {\n      console.error('Error modifying file:', error);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account, getStoredFiles, recordActivity]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback((): string | null => {\n    return encryptionKey;\n  }, [encryptionKey]);\n\n  // Upload a file with encryption (to server)\n  const uploadFile = useCallback(async (file: File, encryptedData: any, key: string): Promise<StoredFile> => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    if (!key) {\n      throw new Error('Encryption key is required');\n    }\n    \n    if (!encryptedData) {\n      throw new Error('No encrypted data provided');\n    }\n    \n    try {\n      setIsLoading(true);\n      const storedFiles = await getStoredFiles();\n      \n      // Check if file with same name already exists\n      const fileExists = storedFiles.some(f => \n        f.name === file.name && \n        f.metadata?.lastModified === file.lastModified\n      );\n      \n      if (fileExists) {\n        throw new Error('A file with this name already exists');\n      }\n      \n      const newFile: StoredFile = {\n        id: crypto.randomUUID(),\n        name: file.name,\n        type: file.type,\n        size: file.size,\n        uploadedAt: new Date().toISOString(),\n        encryptedData: '', // Empty - actual data stored on server\n        metadata: {\n          name: file.name,\n          originalName: file.name,\n          type: file.type,\n          mimeType: file.type,\n          size: file.size,\n          lastModified: file.lastModified\n        }\n      };\n      \n      // Upload encrypted data to server\n      await fileApi.uploadFile({\n        fileId: newFile.id,\n        encryptedData: encryptedData.encryptedData || encryptedData,\n        metadata: newFile.metadata,\n        walletAddress: wallet.account,\n      });\n      \n      return newFile;\n    } catch (error) {\n      console.error('Error uploading file:', error);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account, getStoredFiles]);\n\n  // Check if user is already registered\n  const checkRegistration = useCallback(async (account: string): Promise<boolean> => {\n    try {\n      if (!account) return false;\n      \n      const userData = localStorage.getItem(`user_${account}`);\n      const encryptionKey = localStorage.getItem(`encryption_key_${account}`);\n      \n      if (userData && encryptionKey) {\n        const userProfile = JSON.parse(userData) as UserProfile;\n        setUserProfile(userProfile);\n        setEncryptionKey(encryptionKey);\n        setIsRegistered(true);\n        return true;\n      }\n      \n      // Clear any partial data if registration is not complete\n      localStorage.removeItem(`user_${account}`);\n      localStorage.removeItem(`encryption_key_${account}`);\n      return false;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      setError('Failed to check user registration.');\n      return false;\n    }\n  }, [initializeEncryptionKey]);\n\n  // Validate encryption key against the stored key\n  const validateEncryptionKey = useCallback((key: string): boolean => {\n    if (!wallet.account) return false;\n    const storedKey = localStorage.getItem(`encryption_key_${wallet.account}`);\n    return key === storedKey;\n  }, [wallet.account]);\n\n  // Disconnect wallet\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setWallet({\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null,\n    });\n    setUserProfile(null);\n    setIsRegistered(false);\n    setIsLoading(false);\n    setError(null);\n    setProvider(null);\n    setSigner(null);\n  }, []);\n\n  // Connect wallet\n  const connectWallet = useCallback(async () => {\n    if (typeof window.ethereum === 'undefined') {\n      setError('Please install MetaMask!');\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      const provider = new ethers.BrowserProvider(window.ethereum);\n      const signer = await provider.getSigner();\n      const address = await signer.getAddress();\n      const network = await provider.getNetwork();\n      \n      setProvider(provider);\n      setSigner(signer);\n      setWallet({\n        isConnected: true,\n        account: address,\n        chainId: network.chainId.toString(),\n        balance: null,\n      });\n      setError(null);\n\n      // Check if user is registered\n      const registered = await checkRegistration(address);\n      if (registered) {\n        try { recordActivity('login', 'Wallet connected'); } catch {}\n      }\n    } catch (err) {\n      console.error('Error connecting wallet:', err);\n      setError('Failed to connect wallet. Please try again.');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [checkRegistration]);\n\n  // Register a new user\n  const registerUser = useCallback(async (username: string, email: string = '') => {\n    if (!wallet.account) {\n      return { success: false, message: 'No wallet connected' };\n    }\n\n    try {\n      setIsLoading(true);\n      \n      // Generate a secure encryption key for the user\n      const key = Array.from(window.crypto.getRandomValues(new Uint8Array(32)))\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('');\n      \n      // Create user profile according to UserProfile interface\n      const newUserProfile: UserProfile = {\n        walletAddress: wallet.account,\n        username,\n        email,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n\n      // Store user data and encryption key in localStorage\n      localStorage.setItem(`user_${wallet.account}`, JSON.stringify(newUserProfile));\n      localStorage.setItem(`encryption_key_${wallet.account}`, key);\n      \n      // Update state\n      setUserProfile(newUserProfile);\n      setIsRegistered(true);\n      setEncryptionKey(key);\n\n      // Seed activities with registration considered as login\n      try {\n        const initialActivities = [{ id: crypto.randomUUID(), type: 'login', details: 'Registered and logged in', timestamp: new Date().toISOString() }];\n        localStorage.setItem(`activities_${wallet.account}`, JSON.stringify(initialActivities));\n      } catch {}\n      \n      // Copy the encryption key to clipboard\n      try {\n        await navigator.clipboard.writeText(key);\n        // Also alert the user with the generated key\n        try {\n          window.alert(`Registration successful!\\n\\nYour encryption key (copy kept in clipboard):\\n${key}\\n\\nStore this key safely; it is required for all file operations.`);\n        } catch (e) {\n          // no-op if alert blocked\n        }\n        return { \n          success: true, \n          message: 'Registration successful! Your encryption key has been copied to clipboard. Please keep it safe!',\n          encryptionKey: key\n        };\n      } catch (clipboardError) {\n        console.error('Failed to copy encryption key:', clipboardError);\n        try {\n          window.alert(`Registration successful!\\n\\nPlease copy and save your encryption key:\\n${key}`);\n        } catch (e) {\n          // no-op\n        }\n        return { \n          success: true, \n          message: `Registration successful! Please copy and save your encryption key: ${key}`,\n          encryptionKey: key\n        };\n      }\n    } catch (error) {\n      console.error('Registration failed:', error);\n      return { \n        success: false, \n        message: error instanceof Error ? error.message : 'Registration failed. Please try again.'\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account]);\n\n  const updateUsername = useCallback((newUsername: string) => {\n    if (!wallet.account || !userProfile) return;\n    const updated: UserProfile = { ...userProfile, username: newUsername };\n    localStorage.setItem(`user_${wallet.account}`, JSON.stringify(updated));\n    setUserProfile(updated);\n  }, [wallet.account, userProfile]);\n\n  const getRecentActivities = useCallback((limit: number = 3) => {\n    return getActivities().slice(0, limit);\n  }, [getActivities]);\n\n  const getAllActivities = useCallback(() => {\n    return getActivities();\n  }, [getActivities]);\n\n  const getAllUsers = useCallback(async (): Promise<UserProfile[]> => {\n    const users: UserProfile[] = [];\n    // Local users (same browser)\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (!key) continue;\n      if (key.startsWith('user_')) {\n        try {\n          const parsed = JSON.parse(localStorage.getItem(key) || 'null');\n          if (parsed && parsed.walletAddress) users.push(parsed);\n        } catch {}\n      }\n    }\n\n    // Attempt to augment with on-chain users if connected and configured\n    try {\n      if (provider && contracts?.auth?.address) {\n        // Heuristic: scan recent UserRegistered events for a small block window\n        const ethProvider = provider as unknown as ethers.BrowserProvider;\n        const signer = await ethProvider.getSigner();\n        const contract = new ethers.Contract(contracts.auth.address, BSCIAMAuthABI, signer);\n        const currentBlock = await ethProvider.getBlockNumber();\n        const fromBlock = currentBlock - 5000 > 0 ? currentBlock - 5000 : 0; // last ~5000 blocks\n        // v6 queryFilter across fragments requires passing event name\n        const events = await contract.queryFilter('UserRegistered', fromBlock, currentBlock);\n        for (const ev of events as any[]) {\n          const args: any = (ev as any).args;\n          const user: string = args?.user || args?.[0];\n          if (!user) continue;\n          try {\n            const p: any = await contract.getUserProfile(user);\n            const profile: UserProfile = {\n              walletAddress: p.walletAddress,\n              username: p.username,\n              email: p.email,\n              registrationTime: new Date(Number(p.registrationTime) * 1000).toISOString(),\n              isActive: Boolean(p.isActive),\n              reputationScore: Number(p.reputationScore),\n              accessRoles: Array.from(p.accessRoles || [])\n            };\n            if (!users.find(u => u.walletAddress.toLowerCase() === profile.walletAddress.toLowerCase())) {\n              users.push(profile);\n            }\n          } catch {}\n        }\n      }\n    } catch (e) {\n      console.warn('On-chain user fetch skipped or failed:', e);\n    }\n\n    return users;\n  }, [provider]);\n\n  const value: WalletContextType = {\n    wallet,\n    isRegistered,\n    userProfile,\n    isLoading,\n    error,\n    encryptionKey,\n    connectWallet,\n    disconnectWallet,\n    registerUser,\n    getEncryptionKey: getEncryptionKeyFromState,\n    validateEncryptionKey,\n    getStoredFiles,\n    storeFile,\n    uploadFile,\n    downloadFile: async (fileId: string, key: string) => {\n      console.log('Downloading file:', fileId, 'with key:', key);\n      const files = await getStoredFiles();\n      const file = files.find(f => f.id === fileId);\n      if (!file) throw new Error('File not found');\n      // Encrypted data is fetched in FileList component via API\n      // This method is kept for interface compatibility\n      return;\n    },\n    deleteStoredFile,\n    modifyFile,\n    getRecentActivities,\n    getAllActivities,\n    recordActivity,\n    updateUsername,\n    getAllUsers,\n  };\n\n  return (\n    <WalletContext.Provider value={value}>\n      {children}\n    </WalletContext.Provider>\n  );\n};\n\nexport const useWallet = (): WalletContextType => {\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}