{"ast":null,"code":"import _objectSpread from\"F:/Final Year Project/Project Implementation/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useState,useCallback}from'react';import{ethers}from'ethers';import{generateEncryptionKey}from'../utils/cryptoUtils';import{jsx as _jsx}from\"react/jsx-runtime\";const WalletContext=/*#__PURE__*/createContext(undefined);export const WalletProvider=_ref=>{let{children}=_ref;const[state,setState]=useState({wallet:{isConnected:false,account:null,chainId:null,balance:null},userProfile:null,isRegistered:false,isLoading:false,error:null});const[provider,setProvider]=useState(null);const[signer,setSigner]=useState(null);const[encryptionKey,setEncryptionKey]=useState(null);// Initialize encryption key for the current account\nconst initializeEncryptionKey=useCallback(account=>{let key=localStorage.getItem(\"encryption_key_\".concat(account));if(!key){// Only generate a new key if we're in the registration flow\nreturn null;}setEncryptionKey(key);return key;},[]);// Get stored files for the current user\nconst getStoredFiles=useCallback(()=>{if(!state.wallet.account)return[];const storedFiles=localStorage.getItem(\"user_files_\".concat(state.wallet.account));return storedFiles?JSON.parse(storedFiles):[];},[state.wallet.account]);// Get the user's encryption key\nconst getEncryptionKey=useCallback(()=>{if(!state.wallet.account)return null;return localStorage.getItem(\"encryption_key_\".concat(state.wallet.account));},[state.wallet.account]);// Store a new file\nconst storeFile=useCallback(file=>{if(!state.wallet.account){throw new Error('No wallet connected');}const files=getStoredFiles();// Check if file with same name already exists\nconst existingFileIndex=files.findIndex(f=>f.name===file.name&&f.uploadedAt===file.uploadedAt);let updatedFiles;if(existingFileIndex>=0){// Update existing file\nupdatedFiles=[...files];updatedFiles[existingFileIndex]=file;}else{// Add new file\nupdatedFiles=[...files,file];}localStorage.setItem(\"user_files_\".concat(state.wallet.account),JSON.stringify(updatedFiles));return updatedFiles;},[state.wallet.account,getStoredFiles]);// Delete a file\nconst deleteStoredFile=useCallback(fileId=>{if(!state.wallet.account){throw new Error('No wallet connected');}const files=getStoredFiles();const fileToDelete=files.find(f=>f.id===fileId);if(!fileToDelete){throw new Error('File not found');}const updatedFiles=files.filter(file=>file.id!==fileId);localStorage.setItem(\"user_files_\".concat(state.wallet.account),JSON.stringify(updatedFiles));return updatedFiles;},[state.wallet.account,getStoredFiles]);// Get the current encryption key\nconst getEncryptionKeyFromState=useCallback(()=>{return encryptionKey;},[encryptionKey]);// Check if user is already registered\nconst checkRegistration=useCallback(async()=>{if(!state.wallet.account)return false;try{const userData=localStorage.getItem(\"user_\".concat(state.wallet.account));if(userData){const userProfile=JSON.parse(userData);// Check if encryption key exists\nconst encryptionKey=localStorage.getItem(\"encryption_key_\".concat(state.wallet.account));if(!encryptionKey){// If no encryption key, consider user not properly registered\nreturn false;}setState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered:true,userProfile,encryptionKey}));return true;}return false;}catch(error){console.error('Error checking registration:',error);return false;}},[state.wallet.account]);const disconnectWallet=useCallback(()=>{// Note: We don't clear localStorage here to preserve user data for future logins\nsetState({wallet:{isConnected:false,account:null,chainId:null,balance:null},userProfile:null,isRegistered:false,isLoading:false,error:null});setProvider(null);setSigner(null);},[]);const connectWallet=useCallback(async()=>{if(!window.ethereum){setState(prev=>_objectSpread(_objectSpread({},prev),{},{error:'Please install MetaMask to use this application!'}));return;}try{setState(prev=>_objectSpread(_objectSpread({},prev),{},{isLoading:true,error:null}));// Request account access\nconst accounts=await window.ethereum.request({method:'eth_requestAccounts'});const account=accounts[0];// Get the current network\nconst newProvider=new ethers.BrowserProvider(window.ethereum);const network=await newProvider.getNetwork();const balance=await newProvider.getBalance(account);const newSigner=await newProvider.getSigner();setProvider(newProvider);setSigner(newSigner);// Initialize encryption key for the user\ninitializeEncryptionKey(account);// Update state\nsetState(prev=>_objectSpread(_objectSpread({},prev),{},{wallet:{isConnected:true,account,chainId:network.chainId.toString(),balance:ethers.formatEther(balance)},isLoading:false}));// Check if user is registered\nawait checkRegistration();}catch(error){console.error('Error connecting wallet:',error);setState(prev=>_objectSpread(_objectSpread({},prev),{},{isLoading:false,error:'Failed to connect wallet. Please try again.'}));}},[checkRegistration,initializeEncryptionKey]);const handleAccountsChanged=useCallback(accounts=>{if(accounts.length===0){disconnectWallet();}else{connectWallet();}},[connectWallet,disconnectWallet]);const clearUserData=useCallback(()=>{if(state.wallet.account){localStorage.removeItem(\"user_\".concat(state.wallet.account));// Don't remove the encryption key or files on logout\n// This allows users to access their files when they log back in\n}setState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered:false,userProfile:null,error:null}));},[state.wallet.account]);// Register a new user\nconst registerUser=useCallback(async(username,email)=>{console.log('registerUser called with:',{username,email,account:state.wallet.account});if(!provider||!signer||!state.wallet.account){console.error('registerUser: Wallet not connected',{provider:!!provider,signer:!!signer,account:state.wallet.account});throw new Error('Wallet not connected');}try{setState(prev=>_objectSpread(_objectSpread({},prev),{},{isLoading:true,error:null}));const userProfile={username,email,walletAddress:state.wallet.account,registrationTime:new Date().toISOString(),isActive:true,reputationScore:0,accessRoles:['user']};// Generate a new encryption key for the user\nconst encryptionKey=generateEncryptionKey();// Save user profile and encryption key\nlocalStorage.setItem(\"user_\".concat(state.wallet.account),JSON.stringify(userProfile));localStorage.setItem(\"encryption_key_\".concat(state.wallet.account),encryptionKey);// Update state\nsetState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered:true,userProfile,encryptionKey,isLoading:false,error:null}));// Show the encryption key to the user and prompt them to save it\nconst userConfirmed=window.confirm(\"IMPORTANT: Your encryption key is: \".concat(encryptionKey,\"\\n\\n\")+'Please save this key in a secure place. You will need it to access your files.\\n\\n'+'Have you saved your encryption key?');if(!userConfirmed){// If user didn't confirm, consider registration incomplete\nlocalStorage.removeItem(\"user_\".concat(state.wallet.account));localStorage.removeItem(\"encryption_key_\".concat(state.wallet.account));setState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered:false,userProfile:null,encryptionKey:null}));return false;}return true;}catch(error){console.error('Registration failed:',error);setState(prev=>_objectSpread(_objectSpread({},prev),{},{isLoading:false,error:'Failed to register user. Please try again.'}));return false;}},[provider,signer,state.wallet.account,generateEncryptionKey]);const value={state,connectWallet,disconnectWallet,checkRegistration,registerUser,clearUserData,getEncryptionKey:getEncryptionKeyFromState,getStoredFiles,storeFile,deleteStoredFile:deleteStoredFile,getEncryptionKeyFromState};return/*#__PURE__*/_jsx(WalletContext.Provider,{value:value,children:children});};export const useWallet=()=>{const context=useContext(WalletContext);if(context===undefined){throw new Error('useWallet must be used within a WalletProvider');}return context;};// Extend Window interface for TypeScript","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","ethers","generateEncryptionKey","jsx","_jsx","WalletContext","undefined","WalletProvider","_ref","children","state","setState","wallet","isConnected","account","chainId","balance","userProfile","isRegistered","isLoading","error","provider","setProvider","signer","setSigner","encryptionKey","setEncryptionKey","initializeEncryptionKey","key","localStorage","getItem","concat","getStoredFiles","storedFiles","JSON","parse","getEncryptionKey","storeFile","file","Error","files","existingFileIndex","findIndex","f","name","uploadedAt","updatedFiles","setItem","stringify","deleteStoredFile","fileId","fileToDelete","find","id","filter","getEncryptionKeyFromState","checkRegistration","userData","prev","_objectSpread","console","disconnectWallet","connectWallet","window","ethereum","accounts","request","method","newProvider","BrowserProvider","network","getNetwork","getBalance","newSigner","getSigner","toString","formatEther","handleAccountsChanged","length","clearUserData","removeItem","registerUser","username","email","log","walletAddress","registrationTime","Date","toISOString","isActive","reputationScore","accessRoles","userConfirmed","confirm","value","Provider","useWallet","context"],"sources":["F:/Final Year Project/Project Implementation/frontend/src/context/WalletContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';\nimport { ethers } from 'ethers';\nimport { StoredFile } from '../components/files/FileList';\nimport { AppState, UserProfile } from '../types';\nimport { generateEncryptionKey } from '../utils/cryptoUtils';\n\ninterface WalletContextType {\n  state: AppState;\n  connectWallet: () => Promise<void>;\n  disconnectWallet: () => void;\n  checkRegistration: () => Promise<boolean>;\n  registerUser: (username: string, email: string) => Promise<boolean>;\n  clearUserData: () => void;\n  getEncryptionKey: () => string | null;\n  getStoredFiles: () => StoredFile[];\n  storeFile: (file: StoredFile) => StoredFile[] | undefined;\n  deleteStoredFile: (fileId: string) => StoredFile[];\n  getEncryptionKeyFromState: () => string | null;\n}\n\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\n\ninterface WalletProviderProps {\n  children: ReactNode;\n}\n\nexport const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {\n  const [state, setState] = useState<AppState>({\n    wallet: {\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null,\n    },\n    userProfile: null,\n    isRegistered: false,\n    isLoading: false,\n    error: null,\n  });\n\n  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);\n  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);\n  const [encryptionKey, setEncryptionKey] = useState<string | null>(null);\n\n  // Initialize encryption key for the current account\n  const initializeEncryptionKey = useCallback((account: string) => {\n    let key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) {\n      // Only generate a new key if we're in the registration flow\n      return null;\n    }\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user\n  const getStoredFiles = useCallback((): StoredFile[] => {\n    if (!state.wallet.account) return [];\n    const storedFiles = localStorage.getItem(`user_files_${state.wallet.account}`);\n    return storedFiles ? JSON.parse(storedFiles) : [];\n  }, [state.wallet.account]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback((): string | null => {\n    if (!state.wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${state.wallet.account}`);\n  }, [state.wallet.account]);\n\n  // Store a new file\n  const storeFile = useCallback((file: StoredFile) => {\n    if (!state.wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    // Check if file with same name already exists\n    const existingFileIndex = files.findIndex(f => f.name === file.name && f.uploadedAt === file.uploadedAt);\n    \n    let updatedFiles;\n    if (existingFileIndex >= 0) {\n      // Update existing file\n      updatedFiles = [...files];\n      updatedFiles[existingFileIndex] = file;\n    } else {\n      // Add new file\n      updatedFiles = [...files, file];\n    }\n    \n    localStorage.setItem(\n      `user_files_${state.wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [state.wallet.account, getStoredFiles]);\n\n  // Delete a file\n  const deleteStoredFile = useCallback((fileId: string) => {\n    if (!state.wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    const fileToDelete = files.find(f => f.id === fileId);\n    \n    if (!fileToDelete) {\n      throw new Error('File not found');\n    }\n    \n    const updatedFiles = files.filter(file => file.id !== fileId);\n    \n    localStorage.setItem(\n      `user_files_${state.wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [state.wallet.account, getStoredFiles]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback((): string | null => {\n    return encryptionKey;\n  }, [encryptionKey]);\n\n  // Check if user is already registered\n  const checkRegistration = useCallback(async (): Promise<boolean> => {\n    if (!state.wallet.account) return false;\n    \n    try {\n      const userData = localStorage.getItem(`user_${state.wallet.account}`);\n      if (userData) {\n        const userProfile = JSON.parse(userData) as UserProfile;\n        // Check if encryption key exists\n        const encryptionKey = localStorage.getItem(`encryption_key_${state.wallet.account}`);\n        if (!encryptionKey) {\n          // If no encryption key, consider user not properly registered\n          return false;\n        }\n        \n        setState(prev => ({\n          ...prev,\n          isRegistered: true,\n          userProfile,\n          encryptionKey,\n        }));\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      return false;\n    }\n  }, [state.wallet.account]);\n\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setState({\n      wallet: {\n        isConnected: false,\n        account: null,\n        chainId: null,\n        balance: null,\n      },\n      userProfile: null,\n      isRegistered: false,\n      isLoading: false,\n      error: null,\n    });\n    setProvider(null);\n    setSigner(null);\n  }, []);\n\n  const connectWallet = useCallback(async () => {\n    if (!window.ethereum) {\n      setState(prev => ({\n        ...prev,\n        error: 'Please install MetaMask to use this application!'\n      }));\n      return;\n    }\n\n    try {\n      setState(prev => ({ ...prev, isLoading: true, error: null }));\n\n      // Request account access\n      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });\n      const account = accounts[0];\n\n      // Get the current network\n      const newProvider = new ethers.BrowserProvider(window.ethereum);\n      const network = await newProvider.getNetwork();\n      const balance = await newProvider.getBalance(account);\n      const newSigner = await newProvider.getSigner();\n\n      setProvider(newProvider);\n      setSigner(newSigner);\n\n      // Initialize encryption key for the user\n      initializeEncryptionKey(account);\n\n      // Update state\n      setState(prev => ({\n        ...prev,\n        wallet: {\n          isConnected: true,\n          account,\n          chainId: network.chainId.toString(),\n          balance: ethers.formatEther(balance)\n        },\n        isLoading: false\n      }));\n\n      // Check if user is registered\n      await checkRegistration();\n\n    } catch (error) {\n      console.error('Error connecting wallet:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Failed to connect wallet. Please try again.'\n      }));\n    }\n  }, [checkRegistration, initializeEncryptionKey]);\n\n  const handleAccountsChanged = useCallback((accounts: string[]) => {\n    if (accounts.length === 0) {\n      disconnectWallet();\n    } else {\n      connectWallet();\n    }\n  }, [connectWallet, disconnectWallet]);\n\n  const clearUserData = useCallback(() => {\n    if (state.wallet.account) {\n      localStorage.removeItem(`user_${state.wallet.account}`);\n      // Don't remove the encryption key or files on logout\n      // This allows users to access their files when they log back in\n    }\n    \n    setState(prev => ({\n      ...prev,\n      isRegistered: false,\n      userProfile: null,\n      error: null\n    }));\n  }, [state.wallet.account]);\n\n  // Register a new user\n  const registerUser = useCallback(async (username: string, email: string): Promise<boolean> => {\n    console.log('registerUser called with:', { username, email, account: state.wallet.account });\n    \n    if (!provider || !signer || !state.wallet.account) {\n      console.error('registerUser: Wallet not connected', { provider: !!provider, signer: !!signer, account: state.wallet.account });\n      throw new Error('Wallet not connected');\n    }\n\n    try {\n      setState(prev => ({ ...prev, isLoading: true, error: null }));\n\n      const userProfile: UserProfile = {\n        username,\n        email,\n        walletAddress: state.wallet.account,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n      \n      // Generate a new encryption key for the user\n      const encryptionKey = generateEncryptionKey();\n      \n      // Save user profile and encryption key\n      localStorage.setItem(`user_${state.wallet.account}`, JSON.stringify(userProfile));\n      localStorage.setItem(`encryption_key_${state.wallet.account}`, encryptionKey);\n      \n      // Update state\n      setState(prev => ({\n        ...prev,\n        isRegistered: true,\n        userProfile,\n        encryptionKey,\n        isLoading: false,\n        error: null,\n      }));\n      \n      // Show the encryption key to the user and prompt them to save it\n      const userConfirmed = window.confirm(\n        `IMPORTANT: Your encryption key is: ${encryptionKey}\\n\\n` +\n        'Please save this key in a secure place. You will need it to access your files.\\n\\n' +\n        'Have you saved your encryption key?'\n      );\n      \n      if (!userConfirmed) {\n        // If user didn't confirm, consider registration incomplete\n        localStorage.removeItem(`user_${state.wallet.account}`);\n        localStorage.removeItem(`encryption_key_${state.wallet.account}`);\n        setState(prev => ({\n          ...prev,\n          isRegistered: false,\n          userProfile: null,\n          encryptionKey: null,\n        }));\n        return false;\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Registration failed:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Failed to register user. Please try again.'\n      }));\n      return false;\n    }\n  }, [provider, signer, state.wallet.account, generateEncryptionKey]);\n\n  const value: WalletContextType = {\n    state,\n    connectWallet,\n    disconnectWallet,\n    checkRegistration,\n    registerUser,\n    clearUserData,\n    getEncryptionKey: getEncryptionKeyFromState,\n    getStoredFiles,\n    storeFile,\n    deleteStoredFile: deleteStoredFile as (fileId: string) => StoredFile[],\n    getEncryptionKeyFromState,\n  };\n\n  return (\n    <WalletContext.Provider value={value}>\n      {children}\n    </WalletContext.Provider>\n  );\n};\n\nexport const useWallet = (): WalletContextType => {\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}