{"ast":null,"code":"var _jsxFileName = \"F:\\\\Final Year Project\\\\Project Implementation\\\\BSCIAM-Experimental\\\\frontend\\\\src\\\\context\\\\WalletContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport { BSCIAMAuthABI } from '../config/abi';\nimport contracts from '../config/contracts.json';\nimport { fileApi } from '../services/fileApi';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WalletContext = /*#__PURE__*/createContext(undefined);\nexport const WalletProvider = ({\n  children\n}) => {\n  _s();\n  const [wallet, setWallet] = useState({\n    isConnected: false,\n    account: null,\n    chainId: null,\n    balance: null\n  });\n  const [userProfile, setUserProfile] = useState(null);\n  const [isRegistered, setIsRegistered] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [encryptionKey, setEncryptionKey] = useState(null);\n  const [provider, setProvider] = useState(null);\n  const [signer, setSigner] = useState(null);\n\n  // Initialize encryption key for the current account\n  const initializeEncryptionKey = useCallback(account => {\n    const key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) return null;\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user (from server)\n  const getStoredFiles = useCallback(async () => {\n    if (!wallet.account) return [];\n    try {\n      const files = await fileApi.getFiles(wallet.account);\n      return files;\n    } catch (error) {\n      console.error('Error fetching files from server:', error);\n      return [];\n    }\n  }, [wallet.account]);\n\n  // Activity helpers\n  const getActivities = useCallback(() => {\n    if (!wallet.account) return [];\n    const raw = localStorage.getItem(`activities_${wallet.account}`);\n    return raw ? JSON.parse(raw) : [];\n  }, [wallet.account]);\n  const saveActivities = useCallback(activities => {\n    if (!wallet.account) return;\n    localStorage.setItem(`activities_${wallet.account}`, JSON.stringify(activities));\n  }, [wallet.account]);\n  const bumpReputation = useCallback(() => {\n    if (!wallet.account) return;\n    const userRaw = localStorage.getItem(`user_${wallet.account}`);\n    if (!userRaw) return;\n    const updated = {\n      ...JSON.parse(userRaw),\n      reputationScore: (JSON.parse(userRaw).reputationScore || 0) + 10\n    };\n    localStorage.setItem(`user_${wallet.account}`, JSON.stringify(updated));\n    setUserProfile(updated);\n  }, [wallet.account]);\n  const recordActivity = useCallback((type, details) => {\n    if (!wallet.account) return;\n    const activities = getActivities();\n    const entry = {\n      id: crypto.randomUUID(),\n      type,\n      details,\n      timestamp: new Date().toISOString()\n    };\n    const updated = [entry, ...activities].slice(0, 100);\n    saveActivities(updated);\n    bumpReputation();\n  }, [wallet.account, getActivities, saveActivities, bumpReputation]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback(() => {\n    if (!wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${wallet.account}`);\n  }, [wallet.account]);\n\n  // Store a new file (uploads to server)\n  const storeFile = useCallback(async file => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    if (!file.encryptedData) {\n      throw new Error('File must have encrypted data to store');\n    }\n    try {\n      // Upload to server\n      await fileApi.uploadFile({\n        fileId: file.id,\n        encryptedData: file.encryptedData,\n        metadata: file.metadata,\n        walletAddress: wallet.account\n      });\n\n      // Fetch updated list from server\n      const updatedFiles = await getStoredFiles();\n\n      // Record upload activity\n      try {\n        recordActivity('upload', file.name);\n      } catch {}\n      return updatedFiles;\n    } catch (error) {\n      console.error('Error storing file:', error);\n      throw error;\n    }\n  }, [wallet.account, getStoredFiles, recordActivity]);\n\n  // Delete a file (from server)\n  const deleteStoredFile = useCallback(async fileId => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    try {\n      // Get file info before deletion for activity log\n      const files = await getStoredFiles();\n      const fileToDelete = files.find(f => f.id === fileId);\n\n      // Delete from server\n      await fileApi.deleteFile(fileId, wallet.account);\n\n      // Record activity\n      try {\n        recordActivity('delete', (fileToDelete === null || fileToDelete === void 0 ? void 0 : fileToDelete.name) || 'unknown');\n      } catch {}\n    } catch (error) {\n      console.error('Error deleting file:', error);\n      throw error;\n    }\n  }, [wallet.account, getStoredFiles, recordActivity]);\n\n  // Modify (replace) an existing file (on server)\n  const modifyFile = useCallback(async (fileId, file, encryptedData, key) => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    if (!key) {\n      throw new Error('Encryption key is required');\n    }\n    if (!encryptedData) {\n      throw new Error('No encrypted data provided');\n    }\n    try {\n      setIsLoading(true);\n      const files = await getStoredFiles();\n      const existingFile = files.find(f => f.id === fileId);\n      if (!existingFile) {\n        throw new Error('File not found');\n      }\n\n      // Validate that the new file has the same name and type\n      if (file.name !== existingFile.name) {\n        throw new Error(`File name must match. Expected: ${existingFile.name}, Got: ${file.name}`);\n      }\n      if (file.type !== existingFile.type) {\n        throw new Error(`File type must match. Expected: ${existingFile.type}, Got: ${file.type}`);\n      }\n\n      // Create updated file object with same ID but new data\n      const updatedFile = {\n        id: existingFile.id,\n        // Keep the same ID\n        name: file.name,\n        type: file.type,\n        size: file.size,\n        uploadedAt: new Date().toISOString(),\n        // Update to current time to reflect modification\n        encryptedData: '',\n        // Empty - actual data stored on server\n        metadata: {\n          name: file.name,\n          originalName: file.name,\n          type: file.type,\n          mimeType: file.type,\n          size: file.size,\n          lastModified: file.lastModified\n        }\n      };\n\n      // Update encrypted data on server\n      await fileApi.updateFile(fileId, encryptedData.encryptedData || encryptedData, updatedFile.metadata, wallet.account);\n      try {\n        recordActivity('upload', `Modified: ${file.name}`);\n      } catch {}\n      return updatedFile;\n    } catch (error) {\n      console.error('Error modifying file:', error);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account, getStoredFiles, recordActivity]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback(() => {\n    return encryptionKey;\n  }, [encryptionKey]);\n\n  // Upload a file with encryption (to server)\n  const uploadFile = useCallback(async (file, encryptedData, key) => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    if (!key) {\n      throw new Error('Encryption key is required');\n    }\n    if (!encryptedData) {\n      throw new Error('No encrypted data provided');\n    }\n    try {\n      setIsLoading(true);\n      const storedFiles = await getStoredFiles();\n\n      // Check if file with same name already exists\n      const fileExists = storedFiles.some(f => {\n        var _f$metadata;\n        return f.name === file.name && ((_f$metadata = f.metadata) === null || _f$metadata === void 0 ? void 0 : _f$metadata.lastModified) === file.lastModified;\n      });\n      if (fileExists) {\n        throw new Error('A file with this name already exists');\n      }\n      const newFile = {\n        id: crypto.randomUUID(),\n        name: file.name,\n        type: file.type,\n        size: file.size,\n        uploadedAt: new Date().toISOString(),\n        encryptedData: '',\n        // Empty - actual data stored on server\n        metadata: {\n          name: file.name,\n          originalName: file.name,\n          type: file.type,\n          mimeType: file.type,\n          size: file.size,\n          lastModified: file.lastModified\n        }\n      };\n\n      // Upload encrypted data to server\n      await fileApi.uploadFile({\n        fileId: newFile.id,\n        encryptedData: encryptedData.encryptedData || encryptedData,\n        metadata: newFile.metadata,\n        walletAddress: wallet.account\n      });\n      return newFile;\n    } catch (error) {\n      console.error('Error uploading file:', error);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account, getStoredFiles]);\n\n  // Check if user is already registered\n  const checkRegistration = useCallback(async account => {\n    try {\n      if (!account) return false;\n      const userData = localStorage.getItem(`user_${account}`);\n      const encryptionKey = localStorage.getItem(`encryption_key_${account}`);\n      if (userData && encryptionKey) {\n        const userProfile = JSON.parse(userData);\n        setUserProfile(userProfile);\n        setEncryptionKey(encryptionKey);\n        setIsRegistered(true);\n        return true;\n      }\n\n      // Clear any partial data if registration is not complete\n      localStorage.removeItem(`user_${account}`);\n      localStorage.removeItem(`encryption_key_${account}`);\n      return false;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      setError('Failed to check user registration.');\n      return false;\n    }\n  }, [initializeEncryptionKey]);\n\n  // Validate encryption key against the stored key\n  const validateEncryptionKey = useCallback(key => {\n    if (!wallet.account) return false;\n    const storedKey = localStorage.getItem(`encryption_key_${wallet.account}`);\n    return key === storedKey;\n  }, [wallet.account]);\n\n  // Disconnect wallet\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setWallet({\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null\n    });\n    setUserProfile(null);\n    setIsRegistered(false);\n    setIsLoading(false);\n    setError(null);\n    setProvider(null);\n    setSigner(null);\n  }, []);\n\n  // Connect wallet\n  const connectWallet = useCallback(async () => {\n    if (typeof window.ethereum === 'undefined') {\n      setError('Please install MetaMask!');\n      return;\n    }\n    try {\n      setIsLoading(true);\n      const provider = new ethers.BrowserProvider(window.ethereum);\n      const signer = await provider.getSigner();\n      const address = await signer.getAddress();\n      const network = await provider.getNetwork();\n      setProvider(provider);\n      setSigner(signer);\n      setWallet({\n        isConnected: true,\n        account: address,\n        chainId: network.chainId.toString(),\n        balance: null\n      });\n      setError(null);\n\n      // Check if user is registered\n      const registered = await checkRegistration(address);\n      if (registered) {\n        try {\n          recordActivity('login', 'Wallet connected');\n        } catch {}\n      }\n    } catch (err) {\n      console.error('Error connecting wallet:', err);\n      setError('Failed to connect wallet. Please try again.');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [checkRegistration]);\n\n  // Register a new user\n  const registerUser = useCallback(async (username, email = '') => {\n    if (!wallet.account) {\n      return {\n        success: false,\n        message: 'No wallet connected'\n      };\n    }\n    try {\n      setIsLoading(true);\n\n      // Generate a secure encryption key for the user\n      const key = Array.from(window.crypto.getRandomValues(new Uint8Array(32))).map(b => b.toString(16).padStart(2, '0')).join('');\n\n      // Create user profile according to UserProfile interface\n      const newUserProfile = {\n        walletAddress: wallet.account,\n        username,\n        email,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n\n      // Store user data and encryption key in localStorage\n      localStorage.setItem(`user_${wallet.account}`, JSON.stringify(newUserProfile));\n      localStorage.setItem(`encryption_key_${wallet.account}`, key);\n\n      // Update state\n      setUserProfile(newUserProfile);\n      setIsRegistered(true);\n      setEncryptionKey(key);\n\n      // Seed activities with registration considered as login\n      try {\n        const initialActivities = [{\n          id: crypto.randomUUID(),\n          type: 'login',\n          details: 'Registered and logged in',\n          timestamp: new Date().toISOString()\n        }];\n        localStorage.setItem(`activities_${wallet.account}`, JSON.stringify(initialActivities));\n      } catch {}\n\n      // Copy the encryption key to clipboard\n      try {\n        await navigator.clipboard.writeText(key);\n        // Also alert the user with the generated key\n        try {\n          window.alert(`Registration successful!\\n\\nYour encryption key (copy kept in clipboard):\\n${key}\\n\\nStore this key safely; it is required for all file operations.`);\n        } catch (e) {\n          // no-op if alert blocked\n        }\n        return {\n          success: true,\n          message: 'Registration successful! Your encryption key has been copied to clipboard. Please keep it safe!',\n          encryptionKey: key\n        };\n      } catch (clipboardError) {\n        console.error('Failed to copy encryption key:', clipboardError);\n        try {\n          window.alert(`Registration successful!\\n\\nPlease copy and save your encryption key:\\n${key}`);\n        } catch (e) {\n          // no-op\n        }\n        return {\n          success: true,\n          message: `Registration successful! Please copy and save your encryption key: ${key}`,\n          encryptionKey: key\n        };\n      }\n    } catch (error) {\n      console.error('Registration failed:', error);\n      return {\n        success: false,\n        message: error instanceof Error ? error.message : 'Registration failed. Please try again.'\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account]);\n  const updateUsername = useCallback(newUsername => {\n    if (!wallet.account || !userProfile) return;\n    const updated = {\n      ...userProfile,\n      username: newUsername\n    };\n    localStorage.setItem(`user_${wallet.account}`, JSON.stringify(updated));\n    setUserProfile(updated);\n  }, [wallet.account, userProfile]);\n  const getRecentActivities = useCallback((limit = 3) => {\n    return getActivities().slice(0, limit);\n  }, [getActivities]);\n  const getAllActivities = useCallback(() => {\n    return getActivities();\n  }, [getActivities]);\n  const getAllUsers = useCallback(async () => {\n    const users = [];\n    // Local users (same browser)\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (!key) continue;\n      if (key.startsWith('user_')) {\n        try {\n          const parsed = JSON.parse(localStorage.getItem(key) || 'null');\n          if (parsed && parsed.walletAddress) users.push(parsed);\n        } catch {}\n      }\n    }\n\n    // Attempt to augment with on-chain users if connected and configured\n    try {\n      var _contracts$auth;\n      if (provider && contracts !== null && contracts !== void 0 && (_contracts$auth = contracts.auth) !== null && _contracts$auth !== void 0 && _contracts$auth.address) {\n        // Heuristic: scan recent UserRegistered events for a small block window\n        const ethProvider = provider;\n        const signer = await ethProvider.getSigner();\n        const contract = new ethers.Contract(contracts.auth.address, BSCIAMAuthABI, signer);\n        const currentBlock = await ethProvider.getBlockNumber();\n        const fromBlock = currentBlock - 5000 > 0 ? currentBlock - 5000 : 0; // last ~5000 blocks\n        // v6 queryFilter across fragments requires passing event name\n        const events = await contract.queryFilter('UserRegistered', fromBlock, currentBlock);\n        for (const ev of events) {\n          const args = ev.args;\n          const user = (args === null || args === void 0 ? void 0 : args.user) || (args === null || args === void 0 ? void 0 : args[0]);\n          if (!user) continue;\n          try {\n            const p = await contract.getUserProfile(user);\n            const profile = {\n              walletAddress: p.walletAddress,\n              username: p.username,\n              email: p.email,\n              registrationTime: new Date(Number(p.registrationTime) * 1000).toISOString(),\n              isActive: Boolean(p.isActive),\n              reputationScore: Number(p.reputationScore),\n              accessRoles: Array.from(p.accessRoles || [])\n            };\n            if (!users.find(u => u.walletAddress.toLowerCase() === profile.walletAddress.toLowerCase())) {\n              users.push(profile);\n            }\n          } catch {}\n        }\n      }\n    } catch (e) {\n      console.warn('On-chain user fetch skipped or failed:', e);\n    }\n    return users;\n  }, [provider]);\n  const value = {\n    wallet,\n    isRegistered,\n    userProfile,\n    isLoading,\n    error,\n    encryptionKey,\n    connectWallet,\n    disconnectWallet,\n    registerUser,\n    getEncryptionKey: getEncryptionKeyFromState,\n    validateEncryptionKey,\n    getStoredFiles,\n    storeFile,\n    uploadFile,\n    downloadFile: async (fileId, key) => {\n      console.log('Downloading file:', fileId, 'with key:', key);\n      const files = await getStoredFiles();\n      const file = files.find(f => f.id === fileId);\n      if (!file) throw new Error('File not found');\n      // Encrypted data is fetched in FileList component via API\n      // This method is kept for interface compatibility\n      return;\n    },\n    deleteStoredFile,\n    modifyFile,\n    getRecentActivities,\n    getAllActivities,\n    recordActivity,\n    updateUsername,\n    getAllUsers\n  };\n  return /*#__PURE__*/_jsxDEV(WalletContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 599,\n    columnNumber: 5\n  }, this);\n};\n_s(WalletProvider, \"z6x3AJY+2sTv/1a49ditHGmz9pQ=\");\n_c = WalletProvider;\nexport const useWallet = () => {\n  _s2();\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\n_s2(useWallet, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"WalletProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","ethers","BSCIAMAuthABI","contracts","fileApi","jsxDEV","_jsxDEV","WalletContext","undefined","WalletProvider","children","_s","wallet","setWallet","isConnected","account","chainId","balance","userProfile","setUserProfile","isRegistered","setIsRegistered","isLoading","setIsLoading","error","setError","encryptionKey","setEncryptionKey","provider","setProvider","signer","setSigner","initializeEncryptionKey","key","localStorage","getItem","getStoredFiles","files","getFiles","console","getActivities","raw","JSON","parse","saveActivities","activities","setItem","stringify","bumpReputation","userRaw","updated","reputationScore","recordActivity","type","details","entry","id","crypto","randomUUID","timestamp","Date","toISOString","slice","getEncryptionKey","storeFile","file","Error","encryptedData","uploadFile","fileId","metadata","walletAddress","updatedFiles","name","deleteStoredFile","fileToDelete","find","f","deleteFile","modifyFile","existingFile","updatedFile","size","uploadedAt","originalName","mimeType","lastModified","updateFile","getEncryptionKeyFromState","storedFiles","fileExists","some","_f$metadata","newFile","checkRegistration","userData","removeItem","validateEncryptionKey","storedKey","disconnectWallet","connectWallet","window","ethereum","BrowserProvider","getSigner","address","getAddress","network","getNetwork","toString","registered","err","registerUser","username","email","success","message","Array","from","getRandomValues","Uint8Array","map","b","padStart","join","newUserProfile","registrationTime","isActive","accessRoles","initialActivities","navigator","clipboard","writeText","alert","e","clipboardError","updateUsername","newUsername","getRecentActivities","limit","getAllActivities","getAllUsers","users","i","length","startsWith","parsed","push","_contracts$auth","auth","ethProvider","contract","Contract","currentBlock","getBlockNumber","fromBlock","events","queryFilter","ev","args","user","p","getUserProfile","profile","Number","Boolean","u","toLowerCase","warn","value","downloadFile","log","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useWallet","_s2","context","$RefreshReg$"],"sources":["F:/Final Year Project/Project Implementation/BSCIAM-Experimental/frontend/src/context/WalletContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';\nimport { ethers } from 'ethers';\nimport { BSCIAMAuthABI } from '../config/abi';\nimport contracts from '../config/contracts.json';\nimport { StoredFile } from '../types';\nimport { UserProfile } from '../types';\nimport { fileApi } from '../services/fileApi';\n\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n\ninterface WalletState {\n  isConnected: boolean;\n  account: string | null;\n  chainId: string | null;\n  balance: string | null;\n}\n\ninterface WalletContextType {\n  // Wallet state\n  wallet: WalletState;\n  isRegistered: boolean;\n  userProfile: UserProfile | null;\n  isLoading: boolean;\n  error: string | null;\n  encryptionKey: string | null;\n  \n  // Wallet methods\n  connectWallet: () => Promise<void>;\n  disconnectWallet: () => void;\n  \n  // User methods\n  registerUser: (username: string, email?: string) => Promise<{ \n    success: boolean; \n    message: string; \n    encryptionKey?: string \n  }>;\n  \n  // Encryption methods\n  getEncryptionKey: () => string | null;\n  validateEncryptionKey: (key: string) => boolean;\n  \n  // File methods\n  getStoredFiles: () => Promise<StoredFile[]>;\n  storeFile: (file: StoredFile) => Promise<StoredFile[]>;\n  uploadFile: (file: File, encryptedData: any, key: string) => Promise<StoredFile>;\n  downloadFile: (fileId: string, key: string) => Promise<void>;\n  deleteStoredFile: (fileId: string) => Promise<void>;\n  modifyFile: (fileId: string, file: File, encryptedData: any, key: string) => Promise<StoredFile>;\n\n  // Activity & profile\n  getRecentActivities: (limit?: number) => Array<{ id: string; type: string; details?: string; timestamp: string }>;\n  getAllActivities: () => Array<{ id: string; type: string; details?: string; timestamp: string }>;\n  recordActivity: (type: 'login' | 'upload' | 'download' | 'delete', details?: string) => void;\n  updateUsername: (newUsername: string) => void;\n  getAllUsers: () => Promise<UserProfile[]>;\n}\n\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\n\ninterface WalletProviderProps {\n  children: ReactNode;\n}\n\nexport const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {\n  const [wallet, setWallet] = useState<WalletState>({\n    isConnected: false,\n    account: null,\n    chainId: null,\n    balance: null,\n  });\n  \n  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);\n  const [isRegistered, setIsRegistered] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [encryptionKey, setEncryptionKey] = useState<string | null>(null);\n\n  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);\n  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);\n\n  // Initialize encryption key for the current account\n  const initializeEncryptionKey = useCallback((account: string): string | null => {\n    const key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) return null;\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user (from server)\n  const getStoredFiles = useCallback(async (): Promise<StoredFile[]> => {\n    if (!wallet.account) return [];\n    try {\n      const files = await fileApi.getFiles(wallet.account);\n      return files;\n    } catch (error) {\n      console.error('Error fetching files from server:', error);\n      return [];\n    }\n  }, [wallet.account]);\n\n  // Activity helpers\n  const getActivities = useCallback((): Array<{ id: string; type: string; details?: string; timestamp: string }> => {\n    if (!wallet.account) return [];\n    const raw = localStorage.getItem(`activities_${wallet.account}`);\n    return raw ? JSON.parse(raw) : [];\n  }, [wallet.account]);\n\n  const saveActivities = useCallback((activities: Array<{ id: string; type: string; details?: string; timestamp: string }>) => {\n    if (!wallet.account) return;\n    localStorage.setItem(`activities_${wallet.account}`, JSON.stringify(activities));\n  }, [wallet.account]);\n\n  const bumpReputation = useCallback(() => {\n    if (!wallet.account) return;\n    const userRaw = localStorage.getItem(`user_${wallet.account}`);\n    if (!userRaw) return;\n    const updated: UserProfile = { ...JSON.parse(userRaw), reputationScore: (JSON.parse(userRaw).reputationScore || 0) + 10 };\n    localStorage.setItem(`user_${wallet.account}`, JSON.stringify(updated));\n    setUserProfile(updated);\n  }, [wallet.account]);\n\n  const recordActivity = useCallback((type: 'login' | 'upload' | 'download' | 'delete', details?: string) => {\n    if (!wallet.account) return;\n    const activities = getActivities();\n    const entry = { id: crypto.randomUUID(), type, details, timestamp: new Date().toISOString() };\n    const updated = [entry, ...activities].slice(0, 100);\n    saveActivities(updated);\n    bumpReputation();\n  }, [wallet.account, getActivities, saveActivities, bumpReputation]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback((): string | null => {\n    if (!wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${wallet.account}`);\n  }, [wallet.account]);\n\n  // Store a new file (uploads to server)\n  const storeFile = useCallback(async (file: StoredFile): Promise<StoredFile[]> => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    if (!file.encryptedData) {\n      throw new Error('File must have encrypted data to store');\n    }\n    \n    try {\n      // Upload to server\n      await fileApi.uploadFile({\n        fileId: file.id,\n        encryptedData: file.encryptedData,\n        metadata: file.metadata,\n        walletAddress: wallet.account,\n      });\n      \n      // Fetch updated list from server\n      const updatedFiles = await getStoredFiles();\n      \n    // Record upload activity\n    try { recordActivity('upload', file.name); } catch {}\n      \n    return updatedFiles;\n    } catch (error) {\n      console.error('Error storing file:', error);\n      throw error;\n    }\n  }, [wallet.account, getStoredFiles, recordActivity]);\n\n  // Delete a file (from server)\n  const deleteStoredFile = useCallback(async (fileId: string): Promise<void> => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    try {\n      // Get file info before deletion for activity log\n      const files = await getStoredFiles();\n    const fileToDelete = files.find(f => f.id === fileId);\n    \n      // Delete from server\n      await fileApi.deleteFile(fileId, wallet.account);\n      \n      // Record activity\n      try { recordActivity('delete', fileToDelete?.name || 'unknown'); } catch {}\n    } catch (error) {\n      console.error('Error deleting file:', error);\n      throw error;\n    }\n  }, [wallet.account, getStoredFiles, recordActivity]);\n\n  // Modify (replace) an existing file (on server)\n  const modifyFile = useCallback(async (fileId: string, file: File, encryptedData: any, key: string): Promise<StoredFile> => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    if (!key) {\n      throw new Error('Encryption key is required');\n    }\n    \n    if (!encryptedData) {\n      throw new Error('No encrypted data provided');\n    }\n    \n    try {\n      setIsLoading(true);\n      const files = await getStoredFiles();\n      const existingFile = files.find(f => f.id === fileId);\n      \n      if (!existingFile) {\n        throw new Error('File not found');\n      }\n      \n      // Validate that the new file has the same name and type\n      if (file.name !== existingFile.name) {\n        throw new Error(`File name must match. Expected: ${existingFile.name}, Got: ${file.name}`);\n      }\n      \n      if (file.type !== existingFile.type) {\n        throw new Error(`File type must match. Expected: ${existingFile.type}, Got: ${file.type}`);\n      }\n      \n      // Create updated file object with same ID but new data\n      const updatedFile: StoredFile = {\n        id: existingFile.id, // Keep the same ID\n        name: file.name,\n        type: file.type,\n        size: file.size,\n        uploadedAt: new Date().toISOString(), // Update to current time to reflect modification\n        encryptedData: '', // Empty - actual data stored on server\n        metadata: {\n          name: file.name,\n          originalName: file.name,\n          type: file.type,\n          mimeType: file.type,\n          size: file.size,\n          lastModified: file.lastModified\n        }\n      };\n      \n      // Update encrypted data on server\n      await fileApi.updateFile(\n        fileId,\n        encryptedData.encryptedData || encryptedData,\n        updatedFile.metadata,\n        wallet.account\n      );\n      \n      try { recordActivity('upload', `Modified: ${file.name}`); } catch {}\n      \n      return updatedFile;\n    } catch (error) {\n      console.error('Error modifying file:', error);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account, getStoredFiles, recordActivity]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback((): string | null => {\n    return encryptionKey;\n  }, [encryptionKey]);\n\n  // Upload a file with encryption (to server)\n  const uploadFile = useCallback(async (file: File, encryptedData: any, key: string): Promise<StoredFile> => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    if (!key) {\n      throw new Error('Encryption key is required');\n    }\n    \n    if (!encryptedData) {\n      throw new Error('No encrypted data provided');\n    }\n    \n    try {\n      setIsLoading(true);\n      const storedFiles = await getStoredFiles();\n      \n      // Check if file with same name already exists\n      const fileExists = storedFiles.some(f => \n        f.name === file.name && \n        f.metadata?.lastModified === file.lastModified\n      );\n      \n      if (fileExists) {\n        throw new Error('A file with this name already exists');\n      }\n      \n      const newFile: StoredFile = {\n        id: crypto.randomUUID(),\n        name: file.name,\n        type: file.type,\n        size: file.size,\n        uploadedAt: new Date().toISOString(),\n        encryptedData: '', // Empty - actual data stored on server\n        metadata: {\n          name: file.name,\n          originalName: file.name,\n          type: file.type,\n          mimeType: file.type,\n          size: file.size,\n          lastModified: file.lastModified\n        }\n      };\n      \n      // Upload encrypted data to server\n      await fileApi.uploadFile({\n        fileId: newFile.id,\n        encryptedData: encryptedData.encryptedData || encryptedData,\n        metadata: newFile.metadata,\n        walletAddress: wallet.account,\n      });\n      \n      return newFile;\n    } catch (error) {\n      console.error('Error uploading file:', error);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account, getStoredFiles]);\n\n  // Check if user is already registered\n  const checkRegistration = useCallback(async (account: string): Promise<boolean> => {\n    try {\n      if (!account) return false;\n      \n      const userData = localStorage.getItem(`user_${account}`);\n      const encryptionKey = localStorage.getItem(`encryption_key_${account}`);\n      \n      if (userData && encryptionKey) {\n        const userProfile = JSON.parse(userData) as UserProfile;\n        setUserProfile(userProfile);\n        setEncryptionKey(encryptionKey);\n        setIsRegistered(true);\n        return true;\n      }\n      \n      // Clear any partial data if registration is not complete\n      localStorage.removeItem(`user_${account}`);\n      localStorage.removeItem(`encryption_key_${account}`);\n      return false;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      setError('Failed to check user registration.');\n      return false;\n    }\n  }, [initializeEncryptionKey]);\n\n  // Validate encryption key against the stored key\n  const validateEncryptionKey = useCallback((key: string): boolean => {\n    if (!wallet.account) return false;\n    const storedKey = localStorage.getItem(`encryption_key_${wallet.account}`);\n    return key === storedKey;\n  }, [wallet.account]);\n\n  // Disconnect wallet\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setWallet({\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null,\n    });\n    setUserProfile(null);\n    setIsRegistered(false);\n    setIsLoading(false);\n    setError(null);\n    setProvider(null);\n    setSigner(null);\n  }, []);\n\n  // Connect wallet\n  const connectWallet = useCallback(async () => {\n    if (typeof window.ethereum === 'undefined') {\n      setError('Please install MetaMask!');\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      const provider = new ethers.BrowserProvider(window.ethereum);\n      const signer = await provider.getSigner();\n      const address = await signer.getAddress();\n      const network = await provider.getNetwork();\n      \n      setProvider(provider);\n      setSigner(signer);\n      setWallet({\n        isConnected: true,\n        account: address,\n        chainId: network.chainId.toString(),\n        balance: null,\n      });\n      setError(null);\n\n      // Check if user is registered\n      const registered = await checkRegistration(address);\n      if (registered) {\n        try { recordActivity('login', 'Wallet connected'); } catch {}\n      }\n    } catch (err) {\n      console.error('Error connecting wallet:', err);\n      setError('Failed to connect wallet. Please try again.');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [checkRegistration]);\n\n  // Register a new user\n  const registerUser = useCallback(async (username: string, email: string = '') => {\n    if (!wallet.account) {\n      return { success: false, message: 'No wallet connected' };\n    }\n\n    try {\n      setIsLoading(true);\n      \n      // Generate a secure encryption key for the user\n      const key = Array.from(window.crypto.getRandomValues(new Uint8Array(32)))\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('');\n      \n      // Create user profile according to UserProfile interface\n      const newUserProfile: UserProfile = {\n        walletAddress: wallet.account,\n        username,\n        email,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n\n      // Store user data and encryption key in localStorage\n      localStorage.setItem(`user_${wallet.account}`, JSON.stringify(newUserProfile));\n      localStorage.setItem(`encryption_key_${wallet.account}`, key);\n      \n      // Update state\n      setUserProfile(newUserProfile);\n      setIsRegistered(true);\n      setEncryptionKey(key);\n\n      // Seed activities with registration considered as login\n      try {\n        const initialActivities = [{ id: crypto.randomUUID(), type: 'login', details: 'Registered and logged in', timestamp: new Date().toISOString() }];\n        localStorage.setItem(`activities_${wallet.account}`, JSON.stringify(initialActivities));\n      } catch {}\n      \n      // Copy the encryption key to clipboard\n      try {\n        await navigator.clipboard.writeText(key);\n        // Also alert the user with the generated key\n        try {\n          window.alert(`Registration successful!\\n\\nYour encryption key (copy kept in clipboard):\\n${key}\\n\\nStore this key safely; it is required for all file operations.`);\n        } catch (e) {\n          // no-op if alert blocked\n        }\n        return { \n          success: true, \n          message: 'Registration successful! Your encryption key has been copied to clipboard. Please keep it safe!',\n          encryptionKey: key\n        };\n      } catch (clipboardError) {\n        console.error('Failed to copy encryption key:', clipboardError);\n        try {\n          window.alert(`Registration successful!\\n\\nPlease copy and save your encryption key:\\n${key}`);\n        } catch (e) {\n          // no-op\n        }\n        return { \n          success: true, \n          message: `Registration successful! Please copy and save your encryption key: ${key}`,\n          encryptionKey: key\n        };\n      }\n    } catch (error) {\n      console.error('Registration failed:', error);\n      return { \n        success: false, \n        message: error instanceof Error ? error.message : 'Registration failed. Please try again.'\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account]);\n\n  const updateUsername = useCallback((newUsername: string) => {\n    if (!wallet.account || !userProfile) return;\n    const updated: UserProfile = { ...userProfile, username: newUsername };\n    localStorage.setItem(`user_${wallet.account}`, JSON.stringify(updated));\n    setUserProfile(updated);\n  }, [wallet.account, userProfile]);\n\n  const getRecentActivities = useCallback((limit: number = 3) => {\n    return getActivities().slice(0, limit);\n  }, [getActivities]);\n\n  const getAllActivities = useCallback(() => {\n    return getActivities();\n  }, [getActivities]);\n\n  const getAllUsers = useCallback(async (): Promise<UserProfile[]> => {\n    const users: UserProfile[] = [];\n    // Local users (same browser)\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (!key) continue;\n      if (key.startsWith('user_')) {\n        try {\n          const parsed = JSON.parse(localStorage.getItem(key) || 'null');\n          if (parsed && parsed.walletAddress) users.push(parsed);\n        } catch {}\n      }\n    }\n\n    // Attempt to augment with on-chain users if connected and configured\n    try {\n      if (provider && contracts?.auth?.address) {\n        // Heuristic: scan recent UserRegistered events for a small block window\n        const ethProvider = provider as unknown as ethers.BrowserProvider;\n        const signer = await ethProvider.getSigner();\n        const contract = new ethers.Contract(contracts.auth.address, BSCIAMAuthABI, signer);\n        const currentBlock = await ethProvider.getBlockNumber();\n        const fromBlock = currentBlock - 5000 > 0 ? currentBlock - 5000 : 0; // last ~5000 blocks\n        // v6 queryFilter across fragments requires passing event name\n        const events = await contract.queryFilter('UserRegistered', fromBlock, currentBlock);\n        for (const ev of events as any[]) {\n          const args: any = (ev as any).args;\n          const user: string = args?.user || args?.[0];\n          if (!user) continue;\n          try {\n            const p: any = await contract.getUserProfile(user);\n            const profile: UserProfile = {\n              walletAddress: p.walletAddress,\n              username: p.username,\n              email: p.email,\n              registrationTime: new Date(Number(p.registrationTime) * 1000).toISOString(),\n              isActive: Boolean(p.isActive),\n              reputationScore: Number(p.reputationScore),\n              accessRoles: Array.from(p.accessRoles || [])\n            };\n            if (!users.find(u => u.walletAddress.toLowerCase() === profile.walletAddress.toLowerCase())) {\n              users.push(profile);\n            }\n          } catch {}\n        }\n      }\n    } catch (e) {\n      console.warn('On-chain user fetch skipped or failed:', e);\n    }\n\n    return users;\n  }, [provider]);\n\n  const value: WalletContextType = {\n    wallet,\n    isRegistered,\n    userProfile,\n    isLoading,\n    error,\n    encryptionKey,\n    connectWallet,\n    disconnectWallet,\n    registerUser,\n    getEncryptionKey: getEncryptionKeyFromState,\n    validateEncryptionKey,\n    getStoredFiles,\n    storeFile,\n    uploadFile,\n    downloadFile: async (fileId: string, key: string) => {\n      console.log('Downloading file:', fileId, 'with key:', key);\n      const files = await getStoredFiles();\n      const file = files.find(f => f.id === fileId);\n      if (!file) throw new Error('File not found');\n      // Encrypted data is fetched in FileList component via API\n      // This method is kept for interface compatibility\n      return;\n    },\n    deleteStoredFile,\n    modifyFile,\n    getRecentActivities,\n    getAllActivities,\n    recordActivity,\n    updateUsername,\n    getAllUsers,\n  };\n\n  return (\n    <WalletContext.Provider value={value}>\n      {children}\n    </WalletContext.Provider>\n  );\n};\n\nexport const useWallet = (): WalletContextType => {\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}