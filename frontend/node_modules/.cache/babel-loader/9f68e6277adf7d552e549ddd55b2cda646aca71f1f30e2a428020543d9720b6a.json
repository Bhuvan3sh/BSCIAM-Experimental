{"ast":null,"code":"import React,{createContext,useContext,useState,useCallback}from'react';import{ethers}from'ethers';import{jsx as _jsx}from\"react/jsx-runtime\";const WalletContext=/*#__PURE__*/createContext(undefined);export const WalletProvider=_ref=>{let{children}=_ref;const[wallet,setWallet]=useState({isConnected:false,account:null,chainId:null,balance:null});const[userProfile,setUserProfile]=useState(null);const[isRegistered,setIsRegistered]=useState(false);const[isLoading,setIsLoading]=useState(false);const[error,setError]=useState(null);const[encryptionKey,setEncryptionKey]=useState(null);const[provider,setProvider]=useState(null);const[signer,setSigner]=useState(null);// One-time storage reset on first app load to start fresh\nReact.useEffect(()=>{try{const hasCleared=sessionStorage.getItem('bsciam_storage_cleared');if(!hasCleared){const keysToRemove=[];for(let i=0;i<localStorage.length;i++){const key=localStorage.key(i);if(!key)continue;if(key.startsWith('user_')||key.startsWith('files_')||key.startsWith('encryption_key_')){keysToRemove.push(key);}}keysToRemove.forEach(k=>localStorage.removeItem(k));sessionStorage.setItem('bsciam_storage_cleared','true');}}catch(e){console.error('Failed to clear previous app storage state:',e);}},[]);// Initialize encryption key for the current account\nconst initializeEncryptionKey=useCallback(account=>{const key=localStorage.getItem(\"encryption_key_\".concat(account));if(!key)return null;setEncryptionKey(key);return key;},[]);// Get stored files for the current user\nconst getStoredFiles=useCallback(()=>{if(!wallet.account)return[];const files=localStorage.getItem(\"files_\".concat(wallet.account));return files?JSON.parse(files):[];},[wallet.account]);// Get the user's encryption key\nconst getEncryptionKey=useCallback(()=>{if(!wallet.account)return null;return localStorage.getItem(\"encryption_key_\".concat(wallet.account));},[wallet.account]);// Store a new file\nconst storeFile=useCallback(file=>{if(!wallet.account){throw new Error('No wallet connected');}const files=getStoredFiles();// Check if file with same name already exists\nconst existingFileIndex=files.findIndex(f=>f.name===file.name&&f.uploadedAt===file.uploadedAt);let updatedFiles;if(existingFileIndex>=0){// Update existing file\nupdatedFiles=[...files];updatedFiles[existingFileIndex]=file;}else{// Add new file\nupdatedFiles=[...files,file];}localStorage.setItem(\"files_\".concat(wallet.account),JSON.stringify(updatedFiles));return updatedFiles;},[wallet.account,getStoredFiles]);// Delete a file\nconst deleteStoredFile=useCallback(fileId=>{if(!wallet.account){throw new Error('No wallet connected');}const files=getStoredFiles();const fileToDelete=files.find(f=>f.id===fileId);if(!fileToDelete){throw new Error('File not found');}const updatedFiles=files.filter(file=>file.id!==fileId);localStorage.setItem(\"files_\".concat(wallet.account),JSON.stringify(updatedFiles));return updatedFiles;},[wallet.account,getStoredFiles]);// Get the current encryption key\nconst getEncryptionKeyFromState=useCallback(()=>{return encryptionKey;},[encryptionKey]);// Upload a file with encryption\nconst uploadFile=useCallback(async(file,encryptedData,key)=>{if(!wallet.account){throw new Error('No wallet connected');}if(!key){throw new Error('Encryption key is required');}if(!encryptedData){throw new Error('No encrypted data provided');}try{setIsLoading(true);const storedFiles=getStoredFiles();// Check if file with same name already exists\nconst fileExists=storedFiles.some(f=>{var _f$metadata;return f.name===file.name&&((_f$metadata=f.metadata)===null||_f$metadata===void 0?void 0:_f$metadata.lastModified)===file.lastModified;});if(fileExists){throw new Error('A file with this name already exists');}const newFile={id:crypto.randomUUID(),name:file.name,type:file.type,size:file.size,uploadedAt:new Date().toISOString(),encryptedData,metadata:{name:file.name,originalName:file.name,type:file.type,mimeType:file.type,size:file.size,lastModified:file.lastModified}};const updatedFiles=[...storedFiles,newFile];localStorage.setItem(\"files_\".concat(wallet.account),JSON.stringify(updatedFiles));return newFile;}catch(error){console.error('Error uploading file:',error);throw error;}finally{setIsLoading(false);}},[wallet.account,getStoredFiles]);// Check if user is already registered\nconst checkRegistration=useCallback(async account=>{try{if(!account)return false;const userData=localStorage.getItem(\"user_\".concat(account));const encryptionKey=localStorage.getItem(\"encryption_key_\".concat(account));if(userData&&encryptionKey){const userProfile=JSON.parse(userData);setUserProfile(userProfile);setEncryptionKey(encryptionKey);setIsRegistered(true);return true;}// Clear any partial data if registration is not complete\nlocalStorage.removeItem(\"user_\".concat(account));localStorage.removeItem(\"encryption_key_\".concat(account));return false;}catch(error){console.error('Error checking registration:',error);setError('Failed to check user registration.');return false;}},[initializeEncryptionKey]);// Validate encryption key against the stored key\nconst validateEncryptionKey=useCallback(key=>{if(!wallet.account)return false;const storedKey=localStorage.getItem(\"encryption_key_\".concat(wallet.account));return key===storedKey;},[wallet.account]);// Disconnect wallet\nconst disconnectWallet=useCallback(()=>{// Note: We don't clear localStorage here to preserve user data for future logins\nsetWallet({isConnected:false,account:null,chainId:null,balance:null});setUserProfile(null);setIsRegistered(false);setIsLoading(false);setError(null);setProvider(null);setSigner(null);},[]);// Connect wallet\nconst connectWallet=useCallback(async()=>{if(typeof window.ethereum==='undefined'){setError('Please install MetaMask!');return;}try{setIsLoading(true);const provider=new ethers.BrowserProvider(window.ethereum);const signer=await provider.getSigner();const address=await signer.getAddress();const network=await provider.getNetwork();setProvider(provider);setSigner(signer);setWallet({isConnected:true,account:address,chainId:network.chainId.toString(),balance:null});setError(null);// Check if user is registered\nawait checkRegistration(address);}catch(err){console.error('Error connecting wallet:',err);setError('Failed to connect wallet. Please try again.');}finally{setIsLoading(false);}},[checkRegistration]);// Register a new user\nconst registerUser=useCallback(async function(username){let email=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';if(!wallet.account){return{success:false,message:'No wallet connected'};}try{setIsLoading(true);// Generate a secure encryption key for the user\nconst key=Array.from(window.crypto.getRandomValues(new Uint8Array(32))).map(b=>b.toString(16).padStart(2,'0')).join('');// Create user profile according to UserProfile interface\nconst newUserProfile={walletAddress:wallet.account,username,email,registrationTime:new Date().toISOString(),isActive:true,reputationScore:0,accessRoles:['user']};// Store user data and encryption key in localStorage\nlocalStorage.setItem(\"user_\".concat(wallet.account),JSON.stringify(newUserProfile));localStorage.setItem(\"encryption_key_\".concat(wallet.account),key);// Update state\nsetUserProfile(newUserProfile);setIsRegistered(true);setEncryptionKey(key);// Copy the encryption key to clipboard\ntry{await navigator.clipboard.writeText(key);// Also alert the user with the generated key\ntry{window.alert(\"Registration successful!\\n\\nYour encryption key (copy kept in clipboard):\\n\".concat(key,\"\\n\\nStore this key safely; it is required for all file operations.\"));}catch(e){// no-op if alert blocked\n}return{success:true,message:'Registration successful! Your encryption key has been copied to clipboard. Please keep it safe!',encryptionKey:key};}catch(clipboardError){console.error('Failed to copy encryption key:',clipboardError);try{window.alert(\"Registration successful!\\n\\nPlease copy and save your encryption key:\\n\".concat(key));}catch(e){// no-op\n}return{success:true,message:\"Registration successful! Please copy and save your encryption key: \".concat(key),encryptionKey:key};}}catch(error){console.error('Registration failed:',error);return{success:false,message:error instanceof Error?error.message:'Registration failed. Please try again.'};}finally{setIsLoading(false);}},[wallet.account]);const value={wallet,isRegistered,userProfile,isLoading,error,encryptionKey,connectWallet,disconnectWallet,registerUser,getEncryptionKey:getEncryptionKeyFromState,validateEncryptionKey,getStoredFiles,storeFile,uploadFile,downloadFile:async(fileId,key)=>{// Implement download file logic here\nconsole.log('Downloading file:',fileId,'with key:',key);},deleteStoredFile};return/*#__PURE__*/_jsx(WalletContext.Provider,{value:value,children:children});};export const useWallet=()=>{const context=useContext(WalletContext);if(context===undefined){throw new Error('useWallet must be used within a WalletProvider');}return context;};// Extend Window interface for TypeScript","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","ethers","jsx","_jsx","WalletContext","undefined","WalletProvider","_ref","children","wallet","setWallet","isConnected","account","chainId","balance","userProfile","setUserProfile","isRegistered","setIsRegistered","isLoading","setIsLoading","error","setError","encryptionKey","setEncryptionKey","provider","setProvider","signer","setSigner","useEffect","hasCleared","sessionStorage","getItem","keysToRemove","i","localStorage","length","key","startsWith","push","forEach","k","removeItem","setItem","e","console","initializeEncryptionKey","concat","getStoredFiles","files","JSON","parse","getEncryptionKey","storeFile","file","Error","existingFileIndex","findIndex","f","name","uploadedAt","updatedFiles","stringify","deleteStoredFile","fileId","fileToDelete","find","id","filter","getEncryptionKeyFromState","uploadFile","encryptedData","storedFiles","fileExists","some","_f$metadata","metadata","lastModified","newFile","crypto","randomUUID","type","size","Date","toISOString","originalName","mimeType","checkRegistration","userData","validateEncryptionKey","storedKey","disconnectWallet","connectWallet","window","ethereum","BrowserProvider","getSigner","address","getAddress","network","getNetwork","toString","err","registerUser","username","email","arguments","success","message","Array","from","getRandomValues","Uint8Array","map","b","padStart","join","newUserProfile","walletAddress","registrationTime","isActive","reputationScore","accessRoles","navigator","clipboard","writeText","alert","clipboardError","value","downloadFile","log","Provider","useWallet","context"],"sources":["F:/Final Year Project/Project Implementation/frontend/src/context/WalletContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';\nimport { ethers } from 'ethers';\nimport { StoredFile } from '../types';\nimport { UserProfile } from '../types';\n\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n\ninterface WalletState {\n  isConnected: boolean;\n  account: string | null;\n  chainId: string | null;\n  balance: string | null;\n}\n\ninterface WalletContextType {\n  // Wallet state\n  wallet: WalletState;\n  isRegistered: boolean;\n  userProfile: UserProfile | null;\n  isLoading: boolean;\n  error: string | null;\n  encryptionKey: string | null;\n  \n  // Wallet methods\n  connectWallet: () => Promise<void>;\n  disconnectWallet: () => void;\n  \n  // User methods\n  registerUser: (username: string, email?: string) => Promise<{ \n    success: boolean; \n    message: string; \n    encryptionKey?: string \n  }>;\n  \n  // Encryption methods\n  getEncryptionKey: () => string | null;\n  validateEncryptionKey: (key: string) => boolean;\n  \n  // File methods\n  getStoredFiles: () => StoredFile[];\n  storeFile: (file: StoredFile) => StoredFile[];\n  uploadFile: (file: File, encryptedData: any, key: string) => Promise<StoredFile>;\n  downloadFile: (fileId: string, key: string) => Promise<void>;\n  deleteStoredFile: (fileId: string) => void;\n}\n\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\n\ninterface WalletProviderProps {\n  children: ReactNode;\n}\n\nexport const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {\n  const [wallet, setWallet] = useState<WalletState>({\n    isConnected: false,\n    account: null,\n    chainId: null,\n    balance: null,\n  });\n  \n  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);\n  const [isRegistered, setIsRegistered] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [encryptionKey, setEncryptionKey] = useState<string | null>(null);\n\n  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);\n  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);\n\n  // One-time storage reset on first app load to start fresh\n  React.useEffect(() => {\n    try {\n      const hasCleared = sessionStorage.getItem('bsciam_storage_cleared');\n      if (!hasCleared) {\n        const keysToRemove: string[] = [];\n        for (let i = 0; i < localStorage.length; i++) {\n          const key = localStorage.key(i);\n          if (!key) continue;\n          if (\n            key.startsWith('user_') ||\n            key.startsWith('files_') ||\n            key.startsWith('encryption_key_')\n          ) {\n            keysToRemove.push(key);\n          }\n        }\n        keysToRemove.forEach(k => localStorage.removeItem(k));\n        sessionStorage.setItem('bsciam_storage_cleared', 'true');\n      }\n    } catch (e) {\n      console.error('Failed to clear previous app storage state:', e);\n    }\n  }, []);\n\n  // Initialize encryption key for the current account\n  const initializeEncryptionKey = useCallback((account: string): string | null => {\n    const key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) return null;\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user\n  const getStoredFiles = useCallback((): StoredFile[] => {\n    if (!wallet.account) return [];\n    const files = localStorage.getItem(`files_${wallet.account}`);\n    return files ? JSON.parse(files) : [];\n  }, [wallet.account]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback((): string | null => {\n    if (!wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${wallet.account}`);\n  }, [wallet.account]);\n\n  // Store a new file\n  const storeFile = useCallback((file: StoredFile) => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    // Check if file with same name already exists\n    const existingFileIndex = files.findIndex(f => f.name === file.name && f.uploadedAt === file.uploadedAt);\n    \n    let updatedFiles;\n    if (existingFileIndex >= 0) {\n      // Update existing file\n      updatedFiles = [...files];\n      updatedFiles[existingFileIndex] = file;\n    } else {\n      // Add new file\n      updatedFiles = [...files, file];\n    }\n    \n    localStorage.setItem(\n      `files_${wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [wallet.account, getStoredFiles]);\n\n  // Delete a file\n  const deleteStoredFile = useCallback((fileId: string) => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    const fileToDelete = files.find(f => f.id === fileId);\n    \n    if (!fileToDelete) {\n      throw new Error('File not found');\n    }\n    \n    const updatedFiles = files.filter(file => file.id !== fileId);\n    \n    localStorage.setItem(\n      `files_${wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [wallet.account, getStoredFiles]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback((): string | null => {\n    return encryptionKey;\n  }, [encryptionKey]);\n\n  // Upload a file with encryption\n  const uploadFile = useCallback(async (file: File, encryptedData: any, key: string): Promise<StoredFile> => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    if (!key) {\n      throw new Error('Encryption key is required');\n    }\n    \n    if (!encryptedData) {\n      throw new Error('No encrypted data provided');\n    }\n    \n    try {\n      setIsLoading(true);\n      const storedFiles = getStoredFiles();\n      \n      // Check if file with same name already exists\n      const fileExists = storedFiles.some(f => \n        f.name === file.name && \n        f.metadata?.lastModified === file.lastModified\n      );\n      \n      if (fileExists) {\n        throw new Error('A file with this name already exists');\n      }\n      \n      const newFile: StoredFile = {\n        id: crypto.randomUUID(),\n        name: file.name,\n        type: file.type,\n        size: file.size,\n        uploadedAt: new Date().toISOString(),\n        encryptedData,\n        metadata: {\n          name: file.name,\n          originalName: file.name,\n          type: file.type,\n          mimeType: file.type,\n          size: file.size,\n          lastModified: file.lastModified\n        }\n      };\n      \n      const updatedFiles = [...storedFiles, newFile];\n      localStorage.setItem(`files_${wallet.account}`, JSON.stringify(updatedFiles));\n      \n      return newFile;\n    } catch (error) {\n      console.error('Error uploading file:', error);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account, getStoredFiles]);\n\n  // Check if user is already registered\n  const checkRegistration = useCallback(async (account: string): Promise<boolean> => {\n    try {\n      if (!account) return false;\n      \n      const userData = localStorage.getItem(`user_${account}`);\n      const encryptionKey = localStorage.getItem(`encryption_key_${account}`);\n      \n      if (userData && encryptionKey) {\n        const userProfile = JSON.parse(userData) as UserProfile;\n        setUserProfile(userProfile);\n        setEncryptionKey(encryptionKey);\n        setIsRegistered(true);\n        return true;\n      }\n      \n      // Clear any partial data if registration is not complete\n      localStorage.removeItem(`user_${account}`);\n      localStorage.removeItem(`encryption_key_${account}`);\n      return false;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      setError('Failed to check user registration.');\n      return false;\n    }\n  }, [initializeEncryptionKey]);\n\n  // Validate encryption key against the stored key\n  const validateEncryptionKey = useCallback((key: string): boolean => {\n    if (!wallet.account) return false;\n    const storedKey = localStorage.getItem(`encryption_key_${wallet.account}`);\n    return key === storedKey;\n  }, [wallet.account]);\n\n  // Disconnect wallet\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setWallet({\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null,\n    });\n    setUserProfile(null);\n    setIsRegistered(false);\n    setIsLoading(false);\n    setError(null);\n    setProvider(null);\n    setSigner(null);\n  }, []);\n\n  // Connect wallet\n  const connectWallet = useCallback(async () => {\n    if (typeof window.ethereum === 'undefined') {\n      setError('Please install MetaMask!');\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      const provider = new ethers.BrowserProvider(window.ethereum);\n      const signer = await provider.getSigner();\n      const address = await signer.getAddress();\n      const network = await provider.getNetwork();\n      \n      setProvider(provider);\n      setSigner(signer);\n      setWallet({\n        isConnected: true,\n        account: address,\n        chainId: network.chainId.toString(),\n        balance: null,\n      });\n      setError(null);\n\n      // Check if user is registered\n      await checkRegistration(address);\n    } catch (err) {\n      console.error('Error connecting wallet:', err);\n      setError('Failed to connect wallet. Please try again.');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [checkRegistration]);\n\n  // Register a new user\n  const registerUser = useCallback(async (username: string, email: string = '') => {\n    if (!wallet.account) {\n      return { success: false, message: 'No wallet connected' };\n    }\n\n    try {\n      setIsLoading(true);\n      \n      // Generate a secure encryption key for the user\n      const key = Array.from(window.crypto.getRandomValues(new Uint8Array(32)))\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('');\n      \n      // Create user profile according to UserProfile interface\n      const newUserProfile: UserProfile = {\n        walletAddress: wallet.account,\n        username,\n        email,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n\n      // Store user data and encryption key in localStorage\n      localStorage.setItem(`user_${wallet.account}`, JSON.stringify(newUserProfile));\n      localStorage.setItem(`encryption_key_${wallet.account}`, key);\n      \n      // Update state\n      setUserProfile(newUserProfile);\n      setIsRegistered(true);\n      setEncryptionKey(key);\n      \n      // Copy the encryption key to clipboard\n      try {\n        await navigator.clipboard.writeText(key);\n        // Also alert the user with the generated key\n        try {\n          window.alert(`Registration successful!\\n\\nYour encryption key (copy kept in clipboard):\\n${key}\\n\\nStore this key safely; it is required for all file operations.`);\n        } catch (e) {\n          // no-op if alert blocked\n        }\n        return { \n          success: true, \n          message: 'Registration successful! Your encryption key has been copied to clipboard. Please keep it safe!',\n          encryptionKey: key\n        };\n      } catch (clipboardError) {\n        console.error('Failed to copy encryption key:', clipboardError);\n        try {\n          window.alert(`Registration successful!\\n\\nPlease copy and save your encryption key:\\n${key}`);\n        } catch (e) {\n          // no-op\n        }\n        return { \n          success: true, \n          message: `Registration successful! Please copy and save your encryption key: ${key}`,\n          encryptionKey: key\n        };\n      }\n    } catch (error) {\n      console.error('Registration failed:', error);\n      return { \n        success: false, \n        message: error instanceof Error ? error.message : 'Registration failed. Please try again.'\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account]);\n\n  const value: WalletContextType = {\n    wallet,\n    isRegistered,\n    userProfile,\n    isLoading,\n    error,\n    encryptionKey,\n    connectWallet,\n    disconnectWallet,\n    registerUser,\n    getEncryptionKey: getEncryptionKeyFromState,\n    validateEncryptionKey,\n    getStoredFiles,\n    storeFile,\n    uploadFile,\n    downloadFile: async (fileId: string, key: string) => {\n      // Implement download file logic here\n      console.log('Downloading file:', fileId, 'with key:', key);\n    },\n    deleteStoredFile,\n  };\n\n  return (\n    <WalletContext.Provider value={value}>\n      {children}\n    </WalletContext.Provider>\n  );\n};\n\nexport const useWallet = (): WalletContextType => {\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}