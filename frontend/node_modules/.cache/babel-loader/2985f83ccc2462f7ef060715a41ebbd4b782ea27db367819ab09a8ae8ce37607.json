{"ast":null,"code":"import _objectSpread from\"F:/Final Year Project/Project Implementation/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useEffect,useState,useCallback}from'react';import{ethers}from'ethers';import{jsx as _jsx}from\"react/jsx-runtime\";const WalletContext=/*#__PURE__*/createContext(undefined);export const WalletProvider=_ref=>{let{children}=_ref;const[state,setState]=useState({wallet:{isConnected:false,account:null,chainId:null,balance:null},userProfile:null,isRegistered:false,isLoading:false,error:null});const[provider,setProvider]=useState(null);const[signer,setSigner]=useState(null);const disconnectWallet=useCallback(()=>{// Note: We don't clear localStorage here to preserve user data for future logins\nsetState({wallet:{isConnected:false,account:null,chainId:null,balance:null},userProfile:null,isRegistered:false,isLoading:false,error:null});setProvider(null);setSigner(null);},[]);const connectWallet=useCallback(async()=>{try{setState(prev=>_objectSpread(_objectSpread({},prev),{},{isLoading:true,error:null}));if(typeof window.ethereum==='undefined'){throw new Error('MetaMask is not installed');}const newProvider=new ethers.BrowserProvider(window.ethereum);setProvider(newProvider);const accounts=await window.ethereum.request({method:'eth_requestAccounts'});if(accounts.length===0){throw new Error('No accounts found');}const newSigner=await newProvider.getSigner();setSigner(newSigner);const network=await newProvider.getNetwork();const balance=await newProvider.getBalance(accounts[0]);setState(prev=>_objectSpread(_objectSpread({},prev),{},{wallet:{isConnected:true,account:accounts[0],chainId:network.chainId.toString(),balance:ethers.formatEther(balance)},isLoading:false}));// Check if user is registered and load their data\nawait checkRegistration();}catch(error){setState(prev=>_objectSpread(_objectSpread({},prev),{},{isLoading:false,error:error.message||'Failed to connect wallet'}));}},[]);const handleAccountsChanged=useCallback(accounts=>{if(accounts.length===0){disconnectWallet();}else{connectWallet();}},[connectWallet,disconnectWallet]);const handleChainChanged=useCallback(()=>{window.location.reload();},[]);useEffect(()=>{const initWallet=async()=>{if(typeof window.ethereum!=='undefined'){const newProvider=new ethers.BrowserProvider(window.ethereum);setProvider(newProvider);// Check if already connected\ntry{const accounts=await window.ethereum.request({method:'eth_accounts'});if(accounts.length>0){await connectWallet();}}catch(error){console.error('Error checking existing connection:',error);}// Listen for account changes\nwindow.ethereum.on('accountsChanged',handleAccountsChanged);window.ethereum.on('chainChanged',handleChainChanged);}};initWallet();return()=>{if(window.ethereum){window.ethereum.removeListener('accountsChanged',handleAccountsChanged);window.ethereum.removeListener('chainChanged',handleChainChanged);}};},[connectWallet,handleAccountsChanged,handleChainChanged]);const checkRegistration=useCallback(async()=>{if(!state.wallet.account)return false;try{// Check if user is registered\nconst isRegistered=localStorage.getItem(\"registered_\".concat(state.wallet.account))==='true';if(isRegistered){// Load stored user data\nconst storedUserData=localStorage.getItem(\"userData_\".concat(state.wallet.account));if(storedUserData){const userProfile=JSON.parse(storedUserData);setState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered,userProfile}));}else{setState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered}));}}else{setState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered:false,userProfile:null}));}return isRegistered;}catch(error){console.error('Error checking registration:',error);return false;}},[state.wallet.account]);const registerUser=useCallback(async(username,email)=>{if(!provider||!signer||!state.wallet.account){throw new Error('Wallet not connected');}try{setState(prev=>_objectSpread(_objectSpread({},prev),{},{isLoading:true,error:null}));// This would be implemented with actual contract calls\n// For now, we'll simulate registration\nawait new Promise(resolve=>setTimeout(resolve,2000));// Store registration status\nlocalStorage.setItem(\"registered_\".concat(state.wallet.account),'true');const userProfile={walletAddress:state.wallet.account,username,email,registrationTime:new Date().toISOString(),isActive:true,reputationScore:100,accessRoles:[]};// Store user data for future logins\nlocalStorage.setItem(\"userData_\".concat(state.wallet.account),JSON.stringify(userProfile));setState(prev=>_objectSpread(_objectSpread({},prev),{},{userProfile,isRegistered:true,isLoading:false}));}catch(error){setState(prev=>_objectSpread(_objectSpread({},prev),{},{isLoading:false,error:error.message||'Registration failed'}));throw error;}},[provider,signer,state.wallet.account]);const clearUserData=useCallback(()=>{if(state.wallet.account){localStorage.removeItem(\"registered_\".concat(state.wallet.account));localStorage.removeItem(\"userData_\".concat(state.wallet.account));setState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered:false,userProfile:null}));}},[state.wallet.account]);const value={state,connectWallet,disconnectWallet,checkRegistration,registerUser,clearUserData};return/*#__PURE__*/_jsx(WalletContext.Provider,{value:value,children:children});};export const useWallet=()=>{const context=useContext(WalletContext);if(context===undefined){throw new Error('useWallet must be used within a WalletProvider');}return context;};// Extend Window interface for TypeScript","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","useCallback","ethers","jsx","_jsx","WalletContext","undefined","WalletProvider","_ref","children","state","setState","wallet","isConnected","account","chainId","balance","userProfile","isRegistered","isLoading","error","provider","setProvider","signer","setSigner","disconnectWallet","connectWallet","prev","_objectSpread","window","ethereum","Error","newProvider","BrowserProvider","accounts","request","method","length","newSigner","getSigner","network","getNetwork","getBalance","toString","formatEther","checkRegistration","message","handleAccountsChanged","handleChainChanged","location","reload","initWallet","console","on","removeListener","localStorage","getItem","concat","storedUserData","JSON","parse","registerUser","username","email","Promise","resolve","setTimeout","setItem","walletAddress","registrationTime","Date","toISOString","isActive","reputationScore","accessRoles","stringify","clearUserData","removeItem","value","Provider","useWallet","context"],"sources":["F:/Final Year Project/Project Implementation/frontend/src/context/WalletContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, ReactNode, useCallback } from 'react';\r\nimport { ethers } from 'ethers';\r\nimport { AppState, UserProfile } from '../types';\r\n\r\ninterface WalletContextType {\r\n  state: AppState;\r\n  connectWallet: () => Promise<void>;\r\n  disconnectWallet: () => void;\r\n  checkRegistration: () => Promise<boolean>;\r\n  registerUser: (username: string, email: string) => Promise<void>;\r\n  clearUserData: () => void;\r\n}\r\n\r\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\r\n\r\ninterface WalletProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\nexport const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {\r\n  const [state, setState] = useState<AppState>({\r\n    wallet: {\r\n      isConnected: false,\r\n      account: null,\r\n      chainId: null,\r\n      balance: null,\r\n    },\r\n    userProfile: null,\r\n    isRegistered: false,\r\n    isLoading: false,\r\n    error: null,\r\n  });\r\n\r\n  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);\r\n  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);\r\n\r\n  const disconnectWallet = useCallback(() => {\r\n    // Note: We don't clear localStorage here to preserve user data for future logins\r\n    setState({\r\n      wallet: {\r\n        isConnected: false,\r\n        account: null,\r\n        chainId: null,\r\n        balance: null,\r\n      },\r\n      userProfile: null,\r\n      isRegistered: false,\r\n      isLoading: false,\r\n      error: null,\r\n    });\r\n    setProvider(null);\r\n    setSigner(null);\r\n  }, []);\r\n\r\n  const connectWallet = useCallback(async () => {\r\n    try {\r\n      setState(prev => ({ ...prev, isLoading: true, error: null }));\r\n\r\n      if (typeof window.ethereum === 'undefined') {\r\n        throw new Error('MetaMask is not installed');\r\n      }\r\n\r\n      const newProvider = new ethers.BrowserProvider(window.ethereum);\r\n      setProvider(newProvider);\r\n\r\n      const accounts = await window.ethereum.request({\r\n        method: 'eth_requestAccounts',\r\n      });\r\n\r\n      if (accounts.length === 0) {\r\n        throw new Error('No accounts found');\r\n      }\r\n\r\n      const newSigner = await newProvider.getSigner();\r\n      setSigner(newSigner);\r\n\r\n      const network = await newProvider.getNetwork();\r\n      const balance = await newProvider.getBalance(accounts[0]);\r\n\r\n      setState(prev => ({\r\n        ...prev,\r\n        wallet: {\r\n          isConnected: true,\r\n          account: accounts[0],\r\n          chainId: network.chainId.toString(),\r\n          balance: ethers.formatEther(balance),\r\n        },\r\n        isLoading: false,\r\n      }));\r\n\r\n      // Check if user is registered and load their data\r\n      await checkRegistration();\r\n    } catch (error: any) {\r\n      setState(prev => ({\r\n        ...prev,\r\n        isLoading: false,\r\n        error: error.message || 'Failed to connect wallet',\r\n      }));\r\n    }\r\n  }, []);\r\n\r\n  const handleAccountsChanged = useCallback((accounts: string[]) => {\r\n    if (accounts.length === 0) {\r\n      disconnectWallet();\r\n    } else {\r\n      connectWallet();\r\n    }\r\n  }, [connectWallet, disconnectWallet]);\r\n\r\n  const handleChainChanged = useCallback(() => {\r\n    window.location.reload();\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const initWallet = async () => {\r\n      if (typeof window.ethereum !== 'undefined') {\r\n        const newProvider = new ethers.BrowserProvider(window.ethereum);\r\n        setProvider(newProvider);\r\n\r\n        // Check if already connected\r\n        try {\r\n          const accounts = await window.ethereum.request({ method: 'eth_accounts' });\r\n          if (accounts.length > 0) {\r\n            await connectWallet();\r\n          }\r\n        } catch (error) {\r\n          console.error('Error checking existing connection:', error);\r\n        }\r\n\r\n        // Listen for account changes\r\n        window.ethereum.on('accountsChanged', handleAccountsChanged);\r\n        window.ethereum.on('chainChanged', handleChainChanged);\r\n      }\r\n    };\r\n\r\n    initWallet();\r\n\r\n    return () => {\r\n      if (window.ethereum) {\r\n        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);\r\n        window.ethereum.removeListener('chainChanged', handleChainChanged);\r\n      }\r\n    };\r\n  }, [connectWallet, handleAccountsChanged, handleChainChanged]);\r\n\r\n\r\n  const checkRegistration = useCallback(async (): Promise<boolean> => {\r\n    if (!state.wallet.account) return false;\r\n\r\n    try {\r\n      // Check if user is registered\r\n      const isRegistered = localStorage.getItem(`registered_${state.wallet.account}`) === 'true';\r\n      \r\n      if (isRegistered) {\r\n        // Load stored user data\r\n        const storedUserData = localStorage.getItem(`userData_${state.wallet.account}`);\r\n        if (storedUserData) {\r\n          const userProfile: UserProfile = JSON.parse(storedUserData);\r\n          setState(prev => ({\r\n            ...prev,\r\n            isRegistered,\r\n            userProfile,\r\n          }));\r\n        } else {\r\n          setState(prev => ({\r\n            ...prev,\r\n            isRegistered,\r\n          }));\r\n        }\r\n      } else {\r\n        setState(prev => ({\r\n          ...prev,\r\n          isRegistered: false,\r\n          userProfile: null,\r\n        }));\r\n      }\r\n\r\n      return isRegistered;\r\n    } catch (error) {\r\n      console.error('Error checking registration:', error);\r\n      return false;\r\n    }\r\n  }, [state.wallet.account]);\r\n\r\n  const registerUser = useCallback(async (username: string, email: string) => {\r\n    if (!provider || !signer || !state.wallet.account) {\r\n      throw new Error('Wallet not connected');\r\n    }\r\n\r\n    try {\r\n      setState(prev => ({ ...prev, isLoading: true, error: null }));\r\n\r\n      // This would be implemented with actual contract calls\r\n      // For now, we'll simulate registration\r\n      await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n      // Store registration status\r\n      localStorage.setItem(`registered_${state.wallet.account}`, 'true');\r\n      \r\n      const userProfile: UserProfile = {\r\n        walletAddress: state.wallet.account,\r\n        username,\r\n        email,\r\n        registrationTime: new Date().toISOString(),\r\n        isActive: true,\r\n        reputationScore: 100,\r\n        accessRoles: [],\r\n      };\r\n\r\n      // Store user data for future logins\r\n      localStorage.setItem(`userData_${state.wallet.account}`, JSON.stringify(userProfile));\r\n\r\n      setState(prev => ({\r\n        ...prev,\r\n        userProfile,\r\n        isRegistered: true,\r\n        isLoading: false,\r\n      }));\r\n    } catch (error: any) {\r\n      setState(prev => ({\r\n        ...prev,\r\n        isLoading: false,\r\n        error: error.message || 'Registration failed',\r\n      }));\r\n      throw error;\r\n    }\r\n  }, [provider, signer, state.wallet.account]);\r\n\r\n  const clearUserData = useCallback(() => {\r\n    if (state.wallet.account) {\r\n      localStorage.removeItem(`registered_${state.wallet.account}`);\r\n      localStorage.removeItem(`userData_${state.wallet.account}`);\r\n      setState(prev => ({\r\n        ...prev,\r\n        isRegistered: false,\r\n        userProfile: null,\r\n      }));\r\n    }\r\n  }, [state.wallet.account]);\r\n\r\n  const value: WalletContextType = {\r\n    state,\r\n    connectWallet,\r\n    disconnectWallet,\r\n    checkRegistration,\r\n    registerUser,\r\n    clearUserData,\r\n  };\r\n\r\n  return (\r\n    <WalletContext.Provider value={value}>\r\n      {children}\r\n    </WalletContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useWallet = (): WalletContextType => {\r\n  const context = useContext(WalletContext);\r\n  if (context === undefined) {\r\n    throw new Error('useWallet must be used within a WalletProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n// Extend Window interface for TypeScript\r\ndeclare global {\r\n  interface Window {\r\n    ethereum?: any;\r\n  }\r\n}\r\n"],"mappings":"0IAAA,MAAO,CAAAA,KAAK,EAAIC,aAAa,CAAEC,UAAU,CAAEC,SAAS,CAAEC,QAAQ,CAAaC,WAAW,KAAQ,OAAO,CACrG,OAASC,MAAM,KAAQ,QAAQ,CAAC,OAAAC,GAAA,IAAAC,IAAA,yBAYhC,KAAM,CAAAC,aAAa,cAAGR,aAAa,CAAgCS,SAAS,CAAC,CAM7E,MAAO,MAAM,CAAAC,cAA6C,CAAGC,IAAA,EAAkB,IAAjB,CAAEC,QAAS,CAAC,CAAAD,IAAA,CACxE,KAAM,CAACE,KAAK,CAAEC,QAAQ,CAAC,CAAGX,QAAQ,CAAW,CAC3CY,MAAM,CAAE,CACNC,WAAW,CAAE,KAAK,CAClBC,OAAO,CAAE,IAAI,CACbC,OAAO,CAAE,IAAI,CACbC,OAAO,CAAE,IACX,CAAC,CACDC,WAAW,CAAE,IAAI,CACjBC,YAAY,CAAE,KAAK,CACnBC,SAAS,CAAE,KAAK,CAChBC,KAAK,CAAE,IACT,CAAC,CAAC,CAEF,KAAM,CAACC,QAAQ,CAAEC,WAAW,CAAC,CAAGtB,QAAQ,CAAgC,IAAI,CAAC,CAC7E,KAAM,CAACuB,MAAM,CAAEC,SAAS,CAAC,CAAGxB,QAAQ,CAA8B,IAAI,CAAC,CAEvE,KAAM,CAAAyB,gBAAgB,CAAGxB,WAAW,CAAC,IAAM,CACzC;AACAU,QAAQ,CAAC,CACPC,MAAM,CAAE,CACNC,WAAW,CAAE,KAAK,CAClBC,OAAO,CAAE,IAAI,CACbC,OAAO,CAAE,IAAI,CACbC,OAAO,CAAE,IACX,CAAC,CACDC,WAAW,CAAE,IAAI,CACjBC,YAAY,CAAE,KAAK,CACnBC,SAAS,CAAE,KAAK,CAChBC,KAAK,CAAE,IACT,CAAC,CAAC,CACFE,WAAW,CAAC,IAAI,CAAC,CACjBE,SAAS,CAAC,IAAI,CAAC,CACjB,CAAC,CAAE,EAAE,CAAC,CAEN,KAAM,CAAAE,aAAa,CAAGzB,WAAW,CAAC,SAAY,CAC5C,GAAI,CACFU,QAAQ,CAACgB,IAAI,EAAAC,aAAA,CAAAA,aAAA,IAAUD,IAAI,MAAER,SAAS,CAAE,IAAI,CAAEC,KAAK,CAAE,IAAI,EAAG,CAAC,CAE7D,GAAI,MAAO,CAAAS,MAAM,CAACC,QAAQ,GAAK,WAAW,CAAE,CAC1C,KAAM,IAAI,CAAAC,KAAK,CAAC,2BAA2B,CAAC,CAC9C,CAEA,KAAM,CAAAC,WAAW,CAAG,GAAI,CAAA9B,MAAM,CAAC+B,eAAe,CAACJ,MAAM,CAACC,QAAQ,CAAC,CAC/DR,WAAW,CAACU,WAAW,CAAC,CAExB,KAAM,CAAAE,QAAQ,CAAG,KAAM,CAAAL,MAAM,CAACC,QAAQ,CAACK,OAAO,CAAC,CAC7CC,MAAM,CAAE,qBACV,CAAC,CAAC,CAEF,GAAIF,QAAQ,CAACG,MAAM,GAAK,CAAC,CAAE,CACzB,KAAM,IAAI,CAAAN,KAAK,CAAC,mBAAmB,CAAC,CACtC,CAEA,KAAM,CAAAO,SAAS,CAAG,KAAM,CAAAN,WAAW,CAACO,SAAS,CAAC,CAAC,CAC/Cf,SAAS,CAACc,SAAS,CAAC,CAEpB,KAAM,CAAAE,OAAO,CAAG,KAAM,CAAAR,WAAW,CAACS,UAAU,CAAC,CAAC,CAC9C,KAAM,CAAAzB,OAAO,CAAG,KAAM,CAAAgB,WAAW,CAACU,UAAU,CAACR,QAAQ,CAAC,CAAC,CAAC,CAAC,CAEzDvB,QAAQ,CAACgB,IAAI,EAAAC,aAAA,CAAAA,aAAA,IACRD,IAAI,MACPf,MAAM,CAAE,CACNC,WAAW,CAAE,IAAI,CACjBC,OAAO,CAAEoB,QAAQ,CAAC,CAAC,CAAC,CACpBnB,OAAO,CAAEyB,OAAO,CAACzB,OAAO,CAAC4B,QAAQ,CAAC,CAAC,CACnC3B,OAAO,CAAEd,MAAM,CAAC0C,WAAW,CAAC5B,OAAO,CACrC,CAAC,CACDG,SAAS,CAAE,KAAK,EAChB,CAAC,CAEH;AACA,KAAM,CAAA0B,iBAAiB,CAAC,CAAC,CAC3B,CAAE,MAAOzB,KAAU,CAAE,CACnBT,QAAQ,CAACgB,IAAI,EAAAC,aAAA,CAAAA,aAAA,IACRD,IAAI,MACPR,SAAS,CAAE,KAAK,CAChBC,KAAK,CAAEA,KAAK,CAAC0B,OAAO,EAAI,0BAA0B,EAClD,CAAC,CACL,CACF,CAAC,CAAE,EAAE,CAAC,CAEN,KAAM,CAAAC,qBAAqB,CAAG9C,WAAW,CAAEiC,QAAkB,EAAK,CAChE,GAAIA,QAAQ,CAACG,MAAM,GAAK,CAAC,CAAE,CACzBZ,gBAAgB,CAAC,CAAC,CACpB,CAAC,IAAM,CACLC,aAAa,CAAC,CAAC,CACjB,CACF,CAAC,CAAE,CAACA,aAAa,CAAED,gBAAgB,CAAC,CAAC,CAErC,KAAM,CAAAuB,kBAAkB,CAAG/C,WAAW,CAAC,IAAM,CAC3C4B,MAAM,CAACoB,QAAQ,CAACC,MAAM,CAAC,CAAC,CAC1B,CAAC,CAAE,EAAE,CAAC,CAENnD,SAAS,CAAC,IAAM,CACd,KAAM,CAAAoD,UAAU,CAAG,KAAAA,CAAA,GAAY,CAC7B,GAAI,MAAO,CAAAtB,MAAM,CAACC,QAAQ,GAAK,WAAW,CAAE,CAC1C,KAAM,CAAAE,WAAW,CAAG,GAAI,CAAA9B,MAAM,CAAC+B,eAAe,CAACJ,MAAM,CAACC,QAAQ,CAAC,CAC/DR,WAAW,CAACU,WAAW,CAAC,CAExB;AACA,GAAI,CACF,KAAM,CAAAE,QAAQ,CAAG,KAAM,CAAAL,MAAM,CAACC,QAAQ,CAACK,OAAO,CAAC,CAAEC,MAAM,CAAE,cAAe,CAAC,CAAC,CAC1E,GAAIF,QAAQ,CAACG,MAAM,CAAG,CAAC,CAAE,CACvB,KAAM,CAAAX,aAAa,CAAC,CAAC,CACvB,CACF,CAAE,MAAON,KAAK,CAAE,CACdgC,OAAO,CAAChC,KAAK,CAAC,qCAAqC,CAAEA,KAAK,CAAC,CAC7D,CAEA;AACAS,MAAM,CAACC,QAAQ,CAACuB,EAAE,CAAC,iBAAiB,CAAEN,qBAAqB,CAAC,CAC5DlB,MAAM,CAACC,QAAQ,CAACuB,EAAE,CAAC,cAAc,CAAEL,kBAAkB,CAAC,CACxD,CACF,CAAC,CAEDG,UAAU,CAAC,CAAC,CAEZ,MAAO,IAAM,CACX,GAAItB,MAAM,CAACC,QAAQ,CAAE,CACnBD,MAAM,CAACC,QAAQ,CAACwB,cAAc,CAAC,iBAAiB,CAAEP,qBAAqB,CAAC,CACxElB,MAAM,CAACC,QAAQ,CAACwB,cAAc,CAAC,cAAc,CAAEN,kBAAkB,CAAC,CACpE,CACF,CAAC,CACH,CAAC,CAAE,CAACtB,aAAa,CAAEqB,qBAAqB,CAAEC,kBAAkB,CAAC,CAAC,CAG9D,KAAM,CAAAH,iBAAiB,CAAG5C,WAAW,CAAC,SAA8B,CAClE,GAAI,CAACS,KAAK,CAACE,MAAM,CAACE,OAAO,CAAE,MAAO,MAAK,CAEvC,GAAI,CACF;AACA,KAAM,CAAAI,YAAY,CAAGqC,YAAY,CAACC,OAAO,eAAAC,MAAA,CAAe/C,KAAK,CAACE,MAAM,CAACE,OAAO,CAAE,CAAC,GAAK,MAAM,CAE1F,GAAII,YAAY,CAAE,CAChB;AACA,KAAM,CAAAwC,cAAc,CAAGH,YAAY,CAACC,OAAO,aAAAC,MAAA,CAAa/C,KAAK,CAACE,MAAM,CAACE,OAAO,CAAE,CAAC,CAC/E,GAAI4C,cAAc,CAAE,CAClB,KAAM,CAAAzC,WAAwB,CAAG0C,IAAI,CAACC,KAAK,CAACF,cAAc,CAAC,CAC3D/C,QAAQ,CAACgB,IAAI,EAAAC,aAAA,CAAAA,aAAA,IACRD,IAAI,MACPT,YAAY,CACZD,WAAW,EACX,CAAC,CACL,CAAC,IAAM,CACLN,QAAQ,CAACgB,IAAI,EAAAC,aAAA,CAAAA,aAAA,IACRD,IAAI,MACPT,YAAY,EACZ,CAAC,CACL,CACF,CAAC,IAAM,CACLP,QAAQ,CAACgB,IAAI,EAAAC,aAAA,CAAAA,aAAA,IACRD,IAAI,MACPT,YAAY,CAAE,KAAK,CACnBD,WAAW,CAAE,IAAI,EACjB,CAAC,CACL,CAEA,MAAO,CAAAC,YAAY,CACrB,CAAE,MAAOE,KAAK,CAAE,CACdgC,OAAO,CAAChC,KAAK,CAAC,8BAA8B,CAAEA,KAAK,CAAC,CACpD,MAAO,MAAK,CACd,CACF,CAAC,CAAE,CAACV,KAAK,CAACE,MAAM,CAACE,OAAO,CAAC,CAAC,CAE1B,KAAM,CAAA+C,YAAY,CAAG5D,WAAW,CAAC,MAAO6D,QAAgB,CAAEC,KAAa,GAAK,CAC1E,GAAI,CAAC1C,QAAQ,EAAI,CAACE,MAAM,EAAI,CAACb,KAAK,CAACE,MAAM,CAACE,OAAO,CAAE,CACjD,KAAM,IAAI,CAAAiB,KAAK,CAAC,sBAAsB,CAAC,CACzC,CAEA,GAAI,CACFpB,QAAQ,CAACgB,IAAI,EAAAC,aAAA,CAAAA,aAAA,IAAUD,IAAI,MAAER,SAAS,CAAE,IAAI,CAAEC,KAAK,CAAE,IAAI,EAAG,CAAC,CAE7D;AACA;AACA,KAAM,IAAI,CAAA4C,OAAO,CAACC,OAAO,EAAIC,UAAU,CAACD,OAAO,CAAE,IAAI,CAAC,CAAC,CAEvD;AACAV,YAAY,CAACY,OAAO,eAAAV,MAAA,CAAe/C,KAAK,CAACE,MAAM,CAACE,OAAO,EAAI,MAAM,CAAC,CAElE,KAAM,CAAAG,WAAwB,CAAG,CAC/BmD,aAAa,CAAE1D,KAAK,CAACE,MAAM,CAACE,OAAO,CACnCgD,QAAQ,CACRC,KAAK,CACLM,gBAAgB,CAAE,GAAI,CAAAC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAC1CC,QAAQ,CAAE,IAAI,CACdC,eAAe,CAAE,GAAG,CACpBC,WAAW,CAAE,EACf,CAAC,CAED;AACAnB,YAAY,CAACY,OAAO,aAAAV,MAAA,CAAa/C,KAAK,CAACE,MAAM,CAACE,OAAO,EAAI6C,IAAI,CAACgB,SAAS,CAAC1D,WAAW,CAAC,CAAC,CAErFN,QAAQ,CAACgB,IAAI,EAAAC,aAAA,CAAAA,aAAA,IACRD,IAAI,MACPV,WAAW,CACXC,YAAY,CAAE,IAAI,CAClBC,SAAS,CAAE,KAAK,EAChB,CAAC,CACL,CAAE,MAAOC,KAAU,CAAE,CACnBT,QAAQ,CAACgB,IAAI,EAAAC,aAAA,CAAAA,aAAA,IACRD,IAAI,MACPR,SAAS,CAAE,KAAK,CAChBC,KAAK,CAAEA,KAAK,CAAC0B,OAAO,EAAI,qBAAqB,EAC7C,CAAC,CACH,KAAM,CAAA1B,KAAK,CACb,CACF,CAAC,CAAE,CAACC,QAAQ,CAAEE,MAAM,CAAEb,KAAK,CAACE,MAAM,CAACE,OAAO,CAAC,CAAC,CAE5C,KAAM,CAAA8D,aAAa,CAAG3E,WAAW,CAAC,IAAM,CACtC,GAAIS,KAAK,CAACE,MAAM,CAACE,OAAO,CAAE,CACxByC,YAAY,CAACsB,UAAU,eAAApB,MAAA,CAAe/C,KAAK,CAACE,MAAM,CAACE,OAAO,CAAE,CAAC,CAC7DyC,YAAY,CAACsB,UAAU,aAAApB,MAAA,CAAa/C,KAAK,CAACE,MAAM,CAACE,OAAO,CAAE,CAAC,CAC3DH,QAAQ,CAACgB,IAAI,EAAAC,aAAA,CAAAA,aAAA,IACRD,IAAI,MACPT,YAAY,CAAE,KAAK,CACnBD,WAAW,CAAE,IAAI,EACjB,CAAC,CACL,CACF,CAAC,CAAE,CAACP,KAAK,CAACE,MAAM,CAACE,OAAO,CAAC,CAAC,CAE1B,KAAM,CAAAgE,KAAwB,CAAG,CAC/BpE,KAAK,CACLgB,aAAa,CACbD,gBAAgB,CAChBoB,iBAAiB,CACjBgB,YAAY,CACZe,aACF,CAAC,CAED,mBACExE,IAAA,CAACC,aAAa,CAAC0E,QAAQ,EAACD,KAAK,CAAEA,KAAM,CAAArE,QAAA,CAClCA,QAAQ,CACa,CAAC,CAE7B,CAAC,CAED,MAAO,MAAM,CAAAuE,SAAS,CAAGA,CAAA,GAAyB,CAChD,KAAM,CAAAC,OAAO,CAAGnF,UAAU,CAACO,aAAa,CAAC,CACzC,GAAI4E,OAAO,GAAK3E,SAAS,CAAE,CACzB,KAAM,IAAI,CAAAyB,KAAK,CAAC,gDAAgD,CAAC,CACnE,CACA,MAAO,CAAAkD,OAAO,CAChB,CAAC,CAED","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}