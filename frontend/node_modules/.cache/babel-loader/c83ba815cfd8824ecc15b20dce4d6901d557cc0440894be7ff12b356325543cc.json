{"ast":null,"code":"var _jsxFileName = \"F:\\\\Final Year Project\\\\Project Implementation\\\\frontend\\\\src\\\\context\\\\WalletContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport { generateEncryptionKey } from '../utils/cryptoUtils';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WalletContext = /*#__PURE__*/createContext(undefined);\nexport const WalletProvider = ({\n  children\n}) => {\n  _s();\n  const [state, setState] = useState({\n    wallet: {\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null\n    },\n    userProfile: null,\n    isRegistered: false,\n    isLoading: false,\n    error: null\n  });\n  const [provider, setProvider] = useState(null);\n  const [signer, setSigner] = useState(null);\n  const [encryptionKey, setEncryptionKey] = useState(null);\n\n  // Initialize encryption key for the current account\n  const initializeEncryptionKey = useCallback(account => {\n    let key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) {\n      // Only generate a new key if we're in the registration flow\n      return null;\n    }\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user\n  const getStoredFiles = useCallback(() => {\n    if (!state.wallet.account) return [];\n    const storedFiles = localStorage.getItem(`user_files_${state.wallet.account}`);\n    return storedFiles ? JSON.parse(storedFiles) : [];\n  }, [state.wallet.account]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback(() => {\n    if (!state.wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${state.wallet.account}`);\n  }, [state.wallet.account]);\n\n  // Store a new file\n  const storeFile = useCallback(file => {\n    if (!state.wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    const files = getStoredFiles();\n    // Check if file with same name already exists\n    const existingFileIndex = files.findIndex(f => f.name === file.name && f.uploadedAt === file.uploadedAt);\n    let updatedFiles;\n    if (existingFileIndex >= 0) {\n      // Update existing file\n      updatedFiles = [...files];\n      updatedFiles[existingFileIndex] = file;\n    } else {\n      // Add new file\n      updatedFiles = [...files, file];\n    }\n    localStorage.setItem(`user_files_${state.wallet.account}`, JSON.stringify(updatedFiles));\n    return updatedFiles;\n  }, [state.wallet.account, getStoredFiles]);\n\n  // Delete a file\n  const deleteStoredFile = useCallback(fileId => {\n    if (!state.wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    const files = getStoredFiles();\n    const fileToDelete = files.find(f => f.id === fileId);\n    if (!fileToDelete) {\n      throw new Error('File not found');\n    }\n    const updatedFiles = files.filter(file => file.id !== fileId);\n    localStorage.setItem(`user_files_${state.wallet.account}`, JSON.stringify(updatedFiles));\n    return updatedFiles;\n  }, [state.wallet.account, getStoredFiles]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback(() => {\n    return encryptionKey;\n  }, [encryptionKey]);\n\n  // Check if user is already registered\n  const checkRegistration = useCallback(async () => {\n    if (!state.wallet.account) return false;\n    try {\n      const userData = localStorage.getItem(`user_${state.wallet.account}`);\n      if (userData) {\n        const userProfile = JSON.parse(userData);\n        // Check if encryption key exists\n        const encryptionKey = localStorage.getItem(`encryption_key_${state.wallet.account}`);\n        if (!encryptionKey) {\n          // If no encryption key, consider user not properly registered\n          return false;\n        }\n        setState(prev => ({\n          ...prev,\n          isRegistered: true,\n          userProfile,\n          encryptionKey\n        }));\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      return false;\n    }\n  }, [state.wallet.account]);\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setState({\n      wallet: {\n        isConnected: false,\n        account: null,\n        chainId: null,\n        balance: null\n      },\n      userProfile: null,\n      isRegistered: false,\n      isLoading: false,\n      error: null\n    });\n    setProvider(null);\n    setSigner(null);\n  }, []);\n  const connectWallet = useCallback(async () => {\n    if (!window.ethereum) {\n      setState(prev => ({\n        ...prev,\n        error: 'Please install MetaMask to use this application!'\n      }));\n      return;\n    }\n    try {\n      setState(prev => ({\n        ...prev,\n        isLoading: true,\n        error: null\n      }));\n\n      // Request account access\n      const accounts = await window.ethereum.request({\n        method: 'eth_requestAccounts'\n      });\n      const account = accounts[0];\n\n      // Get the current network\n      const newProvider = new ethers.BrowserProvider(window.ethereum);\n      const network = await newProvider.getNetwork();\n      const balance = await newProvider.getBalance(account);\n      const newSigner = await newProvider.getSigner();\n      setProvider(newProvider);\n      setSigner(newSigner);\n\n      // Initialize encryption key for the user\n      initializeEncryptionKey(account);\n\n      // Update state\n      setState(prev => ({\n        ...prev,\n        wallet: {\n          isConnected: true,\n          account,\n          chainId: network.chainId.toString(),\n          balance: ethers.formatEther(balance)\n        },\n        isLoading: false\n      }));\n\n      // Check if user is registered\n      await checkRegistration();\n    } catch (error) {\n      console.error('Error connecting wallet:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Failed to connect wallet. Please try again.'\n      }));\n    }\n  }, [checkRegistration, initializeEncryptionKey]);\n  const handleAccountsChanged = useCallback(accounts => {\n    if (accounts.length === 0) {\n      disconnectWallet();\n    } else {\n      connectWallet();\n    }\n  }, [connectWallet, disconnectWallet]);\n  const clearUserData = useCallback(() => {\n    if (state.wallet.account) {\n      localStorage.removeItem(`user_${state.wallet.account}`);\n      // Don't remove the encryption key or files on logout\n      // This allows users to access their files when they log back in\n    }\n    setState(prev => ({\n      ...prev,\n      isRegistered: false,\n      userProfile: null,\n      error: null\n    }));\n  }, [state.wallet.account]);\n\n  // Register a new user\n  const registerUser = useCallback(async (username, email) => {\n    console.log('registerUser called with:', {\n      username,\n      email,\n      account: state.wallet.account\n    });\n    if (!provider || !signer || !state.wallet.account) {\n      console.error('registerUser: Wallet not connected', {\n        provider: !!provider,\n        signer: !!signer,\n        account: state.wallet.account\n      });\n      throw new Error('Wallet not connected');\n    }\n    try {\n      setState(prev => ({\n        ...prev,\n        isLoading: true,\n        error: null\n      }));\n      const userProfile = {\n        username,\n        email,\n        walletAddress: state.wallet.account,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n\n      // Generate a new encryption key for the user\n      const encryptionKey = generateEncryptionKey();\n\n      // Save user profile and encryption key\n      localStorage.setItem(`user_${state.wallet.account}`, JSON.stringify(userProfile));\n      localStorage.setItem(`encryption_key_${state.wallet.account}`, encryptionKey);\n\n      // Update state\n      setState(prev => ({\n        ...prev,\n        isRegistered: true,\n        userProfile,\n        encryptionKey,\n        isLoading: false,\n        error: null\n      }));\n\n      // Show the encryption key to the user and prompt them to save it\n      const userConfirmed = window.confirm(`IMPORTANT: Your encryption key is: ${encryptionKey}\\n\\n` + 'Please save this key in a secure place. You will need it to access your files.\\n\\n' + 'Have you saved your encryption key?');\n      if (!userConfirmed) {\n        // If user didn't confirm, consider registration incomplete\n        localStorage.removeItem(`user_${state.wallet.account}`);\n        localStorage.removeItem(`encryption_key_${state.wallet.account}`);\n        setState(prev => ({\n          ...prev,\n          isRegistered: false,\n          userProfile: null,\n          encryptionKey: null\n        }));\n        return false;\n      }\n      return true;\n    } catch (error) {\n      console.error('Registration failed:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Failed to register user. Please try again.'\n      }));\n      return false;\n    }\n  }, [provider, signer, state.wallet.account, generateEncryptionKey]);\n  const value = {\n    state,\n    connectWallet,\n    disconnectWallet,\n    checkRegistration,\n    registerUser,\n    clearUserData,\n    getEncryptionKey: getEncryptionKeyFromState,\n    getStoredFiles,\n    storeFile,\n    deleteStoredFile: deleteStoredFile,\n    getEncryptionKeyFromState\n  };\n  return /*#__PURE__*/_jsxDEV(WalletContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 335,\n    columnNumber: 5\n  }, this);\n};\n_s(WalletProvider, \"P1czdN3qqQZG8KZ6LjQP59abc2o=\");\n_c = WalletProvider;\nexport const useWallet = () => {\n  _s2();\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\n_s2(useWallet, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"WalletProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","ethers","generateEncryptionKey","jsxDEV","_jsxDEV","WalletContext","undefined","WalletProvider","children","_s","state","setState","wallet","isConnected","account","chainId","balance","userProfile","isRegistered","isLoading","error","provider","setProvider","signer","setSigner","encryptionKey","setEncryptionKey","initializeEncryptionKey","key","localStorage","getItem","getStoredFiles","storedFiles","JSON","parse","getEncryptionKey","storeFile","file","Error","files","existingFileIndex","findIndex","f","name","uploadedAt","updatedFiles","setItem","stringify","deleteStoredFile","fileId","fileToDelete","find","id","filter","getEncryptionKeyFromState","checkRegistration","userData","prev","console","disconnectWallet","connectWallet","window","ethereum","accounts","request","method","newProvider","BrowserProvider","network","getNetwork","getBalance","newSigner","getSigner","toString","formatEther","handleAccountsChanged","length","clearUserData","removeItem","registerUser","username","email","log","walletAddress","registrationTime","Date","toISOString","isActive","reputationScore","accessRoles","userConfirmed","confirm","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useWallet","_s2","context","$RefreshReg$"],"sources":["F:/Final Year Project/Project Implementation/frontend/src/context/WalletContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';\nimport { ethers } from 'ethers';\nimport { StoredFile } from '../components/files/FileList';\nimport { AppState, UserProfile } from '../types';\nimport { generateEncryptionKey } from '../utils/cryptoUtils';\n\ninterface WalletContextType {\n  state: AppState;\n  connectWallet: () => Promise<void>;\n  disconnectWallet: () => void;\n  checkRegistration: () => Promise<boolean>;\n  registerUser: (username: string, email: string) => Promise<boolean>;\n  clearUserData: () => void;\n  getEncryptionKey: () => string | null;\n  getStoredFiles: () => StoredFile[];\n  storeFile: (file: StoredFile) => StoredFile[] | undefined;\n  deleteStoredFile: (fileId: string) => StoredFile[];\n  getEncryptionKeyFromState: () => string | null;\n}\n\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\n\ninterface WalletProviderProps {\n  children: ReactNode;\n}\n\nexport const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {\n  const [state, setState] = useState<AppState>({\n    wallet: {\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null,\n    },\n    userProfile: null,\n    isRegistered: false,\n    isLoading: false,\n    error: null,\n  });\n\n  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);\n  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);\n  const [encryptionKey, setEncryptionKey] = useState<string | null>(null);\n\n  // Initialize encryption key for the current account\n  const initializeEncryptionKey = useCallback((account: string) => {\n    let key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) {\n      // Only generate a new key if we're in the registration flow\n      return null;\n    }\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user\n  const getStoredFiles = useCallback((): StoredFile[] => {\n    if (!state.wallet.account) return [];\n    const storedFiles = localStorage.getItem(`user_files_${state.wallet.account}`);\n    return storedFiles ? JSON.parse(storedFiles) : [];\n  }, [state.wallet.account]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback((): string | null => {\n    if (!state.wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${state.wallet.account}`);\n  }, [state.wallet.account]);\n\n  // Store a new file\n  const storeFile = useCallback((file: StoredFile) => {\n    if (!state.wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    // Check if file with same name already exists\n    const existingFileIndex = files.findIndex(f => f.name === file.name && f.uploadedAt === file.uploadedAt);\n    \n    let updatedFiles;\n    if (existingFileIndex >= 0) {\n      // Update existing file\n      updatedFiles = [...files];\n      updatedFiles[existingFileIndex] = file;\n    } else {\n      // Add new file\n      updatedFiles = [...files, file];\n    }\n    \n    localStorage.setItem(\n      `user_files_${state.wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [state.wallet.account, getStoredFiles]);\n\n  // Delete a file\n  const deleteStoredFile = useCallback((fileId: string) => {\n    if (!state.wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    const fileToDelete = files.find(f => f.id === fileId);\n    \n    if (!fileToDelete) {\n      throw new Error('File not found');\n    }\n    \n    const updatedFiles = files.filter(file => file.id !== fileId);\n    \n    localStorage.setItem(\n      `user_files_${state.wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [state.wallet.account, getStoredFiles]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback((): string | null => {\n    return encryptionKey;\n  }, [encryptionKey]);\n\n  // Check if user is already registered\n  const checkRegistration = useCallback(async (): Promise<boolean> => {\n    if (!state.wallet.account) return false;\n    \n    try {\n      const userData = localStorage.getItem(`user_${state.wallet.account}`);\n      if (userData) {\n        const userProfile = JSON.parse(userData) as UserProfile;\n        // Check if encryption key exists\n        const encryptionKey = localStorage.getItem(`encryption_key_${state.wallet.account}`);\n        if (!encryptionKey) {\n          // If no encryption key, consider user not properly registered\n          return false;\n        }\n        \n        setState(prev => ({\n          ...prev,\n          isRegistered: true,\n          userProfile,\n          encryptionKey,\n        }));\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      return false;\n    }\n  }, [state.wallet.account]);\n\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setState({\n      wallet: {\n        isConnected: false,\n        account: null,\n        chainId: null,\n        balance: null,\n      },\n      userProfile: null,\n      isRegistered: false,\n      isLoading: false,\n      error: null,\n    });\n    setProvider(null);\n    setSigner(null);\n  }, []);\n\n  const connectWallet = useCallback(async () => {\n    if (!window.ethereum) {\n      setState(prev => ({\n        ...prev,\n        error: 'Please install MetaMask to use this application!'\n      }));\n      return;\n    }\n\n    try {\n      setState(prev => ({ ...prev, isLoading: true, error: null }));\n\n      // Request account access\n      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });\n      const account = accounts[0];\n\n      // Get the current network\n      const newProvider = new ethers.BrowserProvider(window.ethereum);\n      const network = await newProvider.getNetwork();\n      const balance = await newProvider.getBalance(account);\n      const newSigner = await newProvider.getSigner();\n\n      setProvider(newProvider);\n      setSigner(newSigner);\n\n      // Initialize encryption key for the user\n      initializeEncryptionKey(account);\n\n      // Update state\n      setState(prev => ({\n        ...prev,\n        wallet: {\n          isConnected: true,\n          account,\n          chainId: network.chainId.toString(),\n          balance: ethers.formatEther(balance)\n        },\n        isLoading: false\n      }));\n\n      // Check if user is registered\n      await checkRegistration();\n\n    } catch (error) {\n      console.error('Error connecting wallet:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Failed to connect wallet. Please try again.'\n      }));\n    }\n  }, [checkRegistration, initializeEncryptionKey]);\n\n  const handleAccountsChanged = useCallback((accounts: string[]) => {\n    if (accounts.length === 0) {\n      disconnectWallet();\n    } else {\n      connectWallet();\n    }\n  }, [connectWallet, disconnectWallet]);\n\n  const clearUserData = useCallback(() => {\n    if (state.wallet.account) {\n      localStorage.removeItem(`user_${state.wallet.account}`);\n      // Don't remove the encryption key or files on logout\n      // This allows users to access their files when they log back in\n    }\n    \n    setState(prev => ({\n      ...prev,\n      isRegistered: false,\n      userProfile: null,\n      error: null\n    }));\n  }, [state.wallet.account]);\n\n  // Register a new user\n  const registerUser = useCallback(async (username: string, email: string): Promise<boolean> => {\n    console.log('registerUser called with:', { username, email, account: state.wallet.account });\n    \n    if (!provider || !signer || !state.wallet.account) {\n      console.error('registerUser: Wallet not connected', { provider: !!provider, signer: !!signer, account: state.wallet.account });\n      throw new Error('Wallet not connected');\n    }\n\n    try {\n      setState(prev => ({ ...prev, isLoading: true, error: null }));\n\n      const userProfile: UserProfile = {\n        username,\n        email,\n        walletAddress: state.wallet.account,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n      \n      // Generate a new encryption key for the user\n      const encryptionKey = generateEncryptionKey();\n      \n      // Save user profile and encryption key\n      localStorage.setItem(`user_${state.wallet.account}`, JSON.stringify(userProfile));\n      localStorage.setItem(`encryption_key_${state.wallet.account}`, encryptionKey);\n      \n      // Update state\n      setState(prev => ({\n        ...prev,\n        isRegistered: true,\n        userProfile,\n        encryptionKey,\n        isLoading: false,\n        error: null,\n      }));\n      \n      // Show the encryption key to the user and prompt them to save it\n      const userConfirmed = window.confirm(\n        `IMPORTANT: Your encryption key is: ${encryptionKey}\\n\\n` +\n        'Please save this key in a secure place. You will need it to access your files.\\n\\n' +\n        'Have you saved your encryption key?'\n      );\n      \n      if (!userConfirmed) {\n        // If user didn't confirm, consider registration incomplete\n        localStorage.removeItem(`user_${state.wallet.account}`);\n        localStorage.removeItem(`encryption_key_${state.wallet.account}`);\n        setState(prev => ({\n          ...prev,\n          isRegistered: false,\n          userProfile: null,\n          encryptionKey: null,\n        }));\n        return false;\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Registration failed:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Failed to register user. Please try again.'\n      }));\n      return false;\n    }\n  }, [provider, signer, state.wallet.account, generateEncryptionKey]);\n\n  const value: WalletContextType = {\n    state,\n    connectWallet,\n    disconnectWallet,\n    checkRegistration,\n    registerUser,\n    clearUserData,\n    getEncryptionKey: getEncryptionKeyFromState,\n    getStoredFiles,\n    storeFile,\n    deleteStoredFile: deleteStoredFile as (fileId: string) => StoredFile[],\n    getEncryptionKeyFromState,\n  };\n\n  return (\n    <WalletContext.Provider value={value}>\n      {children}\n    </WalletContext.Provider>\n  );\n};\n\nexport const useWallet = (): WalletContextType => {\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}