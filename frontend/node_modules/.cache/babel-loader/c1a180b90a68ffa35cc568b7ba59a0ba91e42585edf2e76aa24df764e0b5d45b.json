{"ast":null,"code":"import React,{createContext,useContext,useState,useCallback}from'react';import{ethers}from'ethers';import{jsx as _jsx}from\"react/jsx-runtime\";const WalletContext=/*#__PURE__*/createContext(undefined);export const WalletProvider=_ref=>{let{children}=_ref;const[wallet,setWallet]=useState({isConnected:false,account:null,chainId:null,balance:null});const[userProfile,setUserProfile]=useState(null);const[isRegistered,setIsRegistered]=useState(false);const[isLoading,setIsLoading]=useState(false);const[error,setError]=useState(null);const[encryptionKey,setEncryptionKey]=useState(null);const[provider,setProvider]=useState(null);const[signer,setSigner]=useState(null);// Initialize encryption key for the current account\nconst initializeEncryptionKey=useCallback(account=>{const key=localStorage.getItem(\"encryption_key_\".concat(account));if(!key)return null;setEncryptionKey(key);return key;},[]);// Get stored files for the current user\nconst getStoredFiles=useCallback(()=>{if(!wallet.account)return[];const files=localStorage.getItem(\"files_\".concat(wallet.account));return files?JSON.parse(files):[];},[wallet.account]);// Get the user's encryption key\nconst getEncryptionKey=useCallback(()=>{if(!wallet.account)return null;return localStorage.getItem(\"encryption_key_\".concat(wallet.account));},[wallet.account]);// Store a new file\nconst storeFile=useCallback(file=>{if(!wallet.account){throw new Error('No wallet connected');}const files=getStoredFiles();// Check if file with same name already exists\nconst existingFileIndex=files.findIndex(f=>f.name===file.name&&f.uploadedAt===file.uploadedAt);let updatedFiles;if(existingFileIndex>=0){// Update existing file\nupdatedFiles=[...files];updatedFiles[existingFileIndex]=file;}else{// Add new file\nupdatedFiles=[...files,file];}localStorage.setItem(\"files_\".concat(wallet.account),JSON.stringify(updatedFiles));return updatedFiles;},[wallet.account,getStoredFiles]);// Delete a file\nconst deleteStoredFile=useCallback(fileId=>{if(!wallet.account){throw new Error('No wallet connected');}const files=getStoredFiles();const fileToDelete=files.find(f=>f.id===fileId);if(!fileToDelete){throw new Error('File not found');}const updatedFiles=files.filter(file=>file.id!==fileId);localStorage.setItem(\"files_\".concat(wallet.account),JSON.stringify(updatedFiles));return updatedFiles;},[wallet.account,getStoredFiles]);// Get the current encryption key\nconst getEncryptionKeyFromState=useCallback(()=>{return encryptionKey;},[encryptionKey]);// Upload a file with encryption\nconst uploadFile=useCallback(async(file,encryptedData,key)=>{if(!wallet.account)return;const storedFiles=getStoredFiles();const newFile={id:crypto.randomUUID(),name:file.name,type:file.type,size:file.size,uploadedAt:new Date().toISOString(),encryptedData,metadata:{name:file.name,originalName:file.name,type:file.type,mimeType:file.type,size:file.size,lastModified:file.lastModified}};const updatedFiles=[...storedFiles,newFile];localStorage.setItem(\"files_\".concat(wallet.account),JSON.stringify(updatedFiles));},[wallet.account,getStoredFiles]);// Check if user is already registered\nconst checkRegistration=useCallback(async account=>{try{const userData=localStorage.getItem(\"user_\".concat(account));if(userData){const userProfile=JSON.parse(userData);const key=initializeEncryptionKey(account);if(key){setUserProfile(userProfile);setIsRegistered(true);return true;}}return false;}catch(error){console.error('Error checking registration:',error);setError('Failed to check user registration.');return false;}},[initializeEncryptionKey]);// Validate encryption key against the stored key\nconst validateEncryptionKey=useCallback(key=>{if(!wallet.account)return false;const storedKey=localStorage.getItem(\"encryption_key_\".concat(wallet.account));return key===storedKey;},[wallet.account]);// Disconnect wallet\nconst disconnectWallet=useCallback(()=>{// Note: We don't clear localStorage here to preserve user data for future logins\nsetWallet({isConnected:false,account:null,chainId:null,balance:null});setUserProfile(null);setIsRegistered(false);setIsLoading(false);setError(null);setProvider(null);setSigner(null);},[]);// Connect wallet\nconst connectWallet=useCallback(async()=>{if(typeof window.ethereum==='undefined'){setError('Please install MetaMask!');return;}try{setIsLoading(true);const provider=new ethers.BrowserProvider(window.ethereum);const signer=await provider.getSigner();const address=await signer.getAddress();const network=await provider.getNetwork();setProvider(provider);setSigner(signer);setWallet({isConnected:true,account:address,chainId:network.chainId.toString(),balance:null});setError(null);// Check if user is registered\nawait checkRegistration(address);}catch(err){console.error('Error connecting wallet:',err);setError('Failed to connect wallet. Please try again.');}finally{setIsLoading(false);}},[checkRegistration]);// Register a new user\nconst registerUser=useCallback(async function(username){let email=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';if(!wallet.account){return{success:false,message:'No wallet connected'};}try{setIsLoading(true);// Generate a secure encryption key for the user\nconst key=Array.from(window.crypto.getRandomValues(new Uint8Array(32))).map(b=>b.toString(16).padStart(2,'0')).join('');// Create user profile according to UserProfile interface\nconst newUserProfile={walletAddress:wallet.account,username,email,registrationTime:new Date().toISOString(),isActive:true,reputationScore:0,accessRoles:['user']};// Store user data and encryption key in localStorage\nlocalStorage.setItem(\"user_\".concat(wallet.account),JSON.stringify(newUserProfile));localStorage.setItem(\"encryption_key_\".concat(wallet.account),key);// Update state\nsetUserProfile(newUserProfile);setIsRegistered(true);setEncryptionKey(key);// Copy the encryption key to clipboard\ntry{await navigator.clipboard.writeText(key);return{success:true,message:'Registration successful! Your encryption key has been copied to clipboard. Please keep it safe!',encryptionKey:key};}catch(clipboardError){console.error('Failed to copy encryption key:',clipboardError);return{success:true,message:\"Registration successful! Please copy and save your encryption key: \".concat(key),encryptionKey:key};}}catch(error){console.error('Registration failed:',error);return{success:false,message:error instanceof Error?error.message:'Registration failed. Please try again.'};}finally{setIsLoading(false);}},[wallet.account]);const value={wallet,isRegistered,userProfile,isLoading,error,encryptionKey,connectWallet,disconnectWallet,registerUser,getEncryptionKey:getEncryptionKeyFromState,validateEncryptionKey,getStoredFiles,storeFile,uploadFile,downloadFile:async(fileId,key)=>{// Implement download file logic here\nconsole.log('Downloading file:',fileId,'with key:',key);},deleteStoredFile};return/*#__PURE__*/_jsx(WalletContext.Provider,{value:value,children:children});};export const useWallet=()=>{const context=useContext(WalletContext);if(context===undefined){throw new Error('useWallet must be used within a WalletProvider');}return context;};// Extend Window interface for TypeScript","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","ethers","jsx","_jsx","WalletContext","undefined","WalletProvider","_ref","children","wallet","setWallet","isConnected","account","chainId","balance","userProfile","setUserProfile","isRegistered","setIsRegistered","isLoading","setIsLoading","error","setError","encryptionKey","setEncryptionKey","provider","setProvider","signer","setSigner","initializeEncryptionKey","key","localStorage","getItem","concat","getStoredFiles","files","JSON","parse","getEncryptionKey","storeFile","file","Error","existingFileIndex","findIndex","f","name","uploadedAt","updatedFiles","setItem","stringify","deleteStoredFile","fileId","fileToDelete","find","id","filter","getEncryptionKeyFromState","uploadFile","encryptedData","storedFiles","newFile","crypto","randomUUID","type","size","Date","toISOString","metadata","originalName","mimeType","lastModified","checkRegistration","userData","console","validateEncryptionKey","storedKey","disconnectWallet","connectWallet","window","ethereum","BrowserProvider","getSigner","address","getAddress","network","getNetwork","toString","err","registerUser","username","email","arguments","length","success","message","Array","from","getRandomValues","Uint8Array","map","b","padStart","join","newUserProfile","walletAddress","registrationTime","isActive","reputationScore","accessRoles","navigator","clipboard","writeText","clipboardError","value","downloadFile","log","Provider","useWallet","context"],"sources":["F:/Final Year Project/Project Implementation/frontend/src/context/WalletContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';\nimport { ethers } from 'ethers';\nimport { StoredFile } from '../types';\nimport { UserProfile } from '../types';\n\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n\ninterface WalletState {\n  isConnected: boolean;\n  account: string | null;\n  chainId: string | null;\n  balance: string | null;\n}\n\ninterface WalletContextType {\n  // Wallet state\n  wallet: WalletState;\n  isRegistered: boolean;\n  userProfile: UserProfile | null;\n  isLoading: boolean;\n  error: string | null;\n  encryptionKey: string | null;\n  \n  // Wallet methods\n  connectWallet: () => Promise<void>;\n  disconnectWallet: () => void;\n  \n  // User methods\n  registerUser: (username: string, email?: string) => Promise<{ \n    success: boolean; \n    message: string; \n    encryptionKey?: string \n  }>;\n  \n  // Encryption methods\n  getEncryptionKey: () => string | null;\n  validateEncryptionKey: (key: string) => boolean;\n  \n  // File methods\n  getStoredFiles: () => StoredFile[];\n  storeFile: (file: StoredFile) => StoredFile[];\n  uploadFile: (file: File, encryptedData: any, key: string) => Promise<void>;\n  downloadFile: (fileId: string, key: string) => Promise<void>;\n  deleteStoredFile: (fileId: string) => void;\n}\n\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\n\ninterface WalletProviderProps {\n  children: ReactNode;\n}\n\nexport const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {\n  const [wallet, setWallet] = useState<WalletState>({\n    isConnected: false,\n    account: null,\n    chainId: null,\n    balance: null,\n  });\n  \n  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);\n  const [isRegistered, setIsRegistered] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [encryptionKey, setEncryptionKey] = useState<string | null>(null);\n\n  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);\n  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);\n\n  // Initialize encryption key for the current account\n  const initializeEncryptionKey = useCallback((account: string): string | null => {\n    const key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) return null;\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user\n  const getStoredFiles = useCallback((): StoredFile[] => {\n    if (!wallet.account) return [];\n    const files = localStorage.getItem(`files_${wallet.account}`);\n    return files ? JSON.parse(files) : [];\n  }, [wallet.account]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback((): string | null => {\n    if (!wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${wallet.account}`);\n  }, [wallet.account]);\n\n  // Store a new file\n  const storeFile = useCallback((file: StoredFile) => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    // Check if file with same name already exists\n    const existingFileIndex = files.findIndex(f => f.name === file.name && f.uploadedAt === file.uploadedAt);\n    \n    let updatedFiles;\n    if (existingFileIndex >= 0) {\n      // Update existing file\n      updatedFiles = [...files];\n      updatedFiles[existingFileIndex] = file;\n    } else {\n      // Add new file\n      updatedFiles = [...files, file];\n    }\n    \n    localStorage.setItem(\n      `files_${wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [wallet.account, getStoredFiles]);\n\n  // Delete a file\n  const deleteStoredFile = useCallback((fileId: string) => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    const fileToDelete = files.find(f => f.id === fileId);\n    \n    if (!fileToDelete) {\n      throw new Error('File not found');\n    }\n    \n    const updatedFiles = files.filter(file => file.id !== fileId);\n    \n    localStorage.setItem(\n      `files_${wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [wallet.account, getStoredFiles]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback((): string | null => {\n    return encryptionKey;\n  }, [encryptionKey]);\n\n  // Upload a file with encryption\n  const uploadFile = useCallback(async (file: File, encryptedData: any, key: string): Promise<void> => {\n    if (!wallet.account) return;\n    \n    const storedFiles = getStoredFiles();\n    const newFile: StoredFile = {\n      id: crypto.randomUUID(),\n      name: file.name,\n      type: file.type,\n      size: file.size,\n      uploadedAt: new Date().toISOString(),\n      encryptedData,\n      metadata: {\n        name: file.name,\n        originalName: file.name,\n        type: file.type,\n        mimeType: file.type,\n        size: file.size,\n        lastModified: file.lastModified\n      }\n    };\n    \n    const updatedFiles = [...storedFiles, newFile];\n    localStorage.setItem(`files_${wallet.account}`, JSON.stringify(updatedFiles));\n  }, [wallet.account, getStoredFiles]);\n\n  // Check if user is already registered\n  const checkRegistration = useCallback(async (account: string): Promise<boolean> => {\n    try {\n      const userData = localStorage.getItem(`user_${account}`);\n      if (userData) {\n        const userProfile = JSON.parse(userData) as UserProfile;\n        const key = initializeEncryptionKey(account);\n        if (key) {\n          setUserProfile(userProfile);\n          setIsRegistered(true);\n          return true;\n        }\n      }\n      return false;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      setError('Failed to check user registration.');\n      return false;\n    }\n  }, [initializeEncryptionKey]);\n\n  // Validate encryption key against the stored key\n  const validateEncryptionKey = useCallback((key: string): boolean => {\n    if (!wallet.account) return false;\n    const storedKey = localStorage.getItem(`encryption_key_${wallet.account}`);\n    return key === storedKey;\n  }, [wallet.account]);\n\n  // Disconnect wallet\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setWallet({\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null,\n    });\n    setUserProfile(null);\n    setIsRegistered(false);\n    setIsLoading(false);\n    setError(null);\n    setProvider(null);\n    setSigner(null);\n  }, []);\n\n  // Connect wallet\n  const connectWallet = useCallback(async () => {\n    if (typeof window.ethereum === 'undefined') {\n      setError('Please install MetaMask!');\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      const provider = new ethers.BrowserProvider(window.ethereum);\n      const signer = await provider.getSigner();\n      const address = await signer.getAddress();\n      const network = await provider.getNetwork();\n      \n      setProvider(provider);\n      setSigner(signer);\n      setWallet({\n        isConnected: true,\n        account: address,\n        chainId: network.chainId.toString(),\n        balance: null,\n      });\n      setError(null);\n\n      // Check if user is registered\n      await checkRegistration(address);\n    } catch (err) {\n      console.error('Error connecting wallet:', err);\n      setError('Failed to connect wallet. Please try again.');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [checkRegistration]);\n\n  // Register a new user\n  const registerUser = useCallback(async (username: string, email: string = '') => {\n    if (!wallet.account) {\n      return { success: false, message: 'No wallet connected' };\n    }\n\n    try {\n      setIsLoading(true);\n      \n      // Generate a secure encryption key for the user\n      const key = Array.from(window.crypto.getRandomValues(new Uint8Array(32)))\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('');\n      \n      // Create user profile according to UserProfile interface\n      const newUserProfile: UserProfile = {\n        walletAddress: wallet.account,\n        username,\n        email,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n\n      // Store user data and encryption key in localStorage\n      localStorage.setItem(`user_${wallet.account}`, JSON.stringify(newUserProfile));\n      localStorage.setItem(`encryption_key_${wallet.account}`, key);\n      \n      // Update state\n      setUserProfile(newUserProfile);\n      setIsRegistered(true);\n      setEncryptionKey(key);\n      \n      // Copy the encryption key to clipboard\n      try {\n        await navigator.clipboard.writeText(key);\n        return { \n          success: true, \n          message: 'Registration successful! Your encryption key has been copied to clipboard. Please keep it safe!',\n          encryptionKey: key\n        };\n      } catch (clipboardError) {\n        console.error('Failed to copy encryption key:', clipboardError);\n        return { \n          success: true, \n          message: `Registration successful! Please copy and save your encryption key: ${key}`,\n          encryptionKey: key\n        };\n      }\n    } catch (error) {\n      console.error('Registration failed:', error);\n      return { \n        success: false, \n        message: error instanceof Error ? error.message : 'Registration failed. Please try again.'\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account]);\n\n  const value: WalletContextType = {\n    wallet,\n    isRegistered,\n    userProfile,\n    isLoading,\n    error,\n    encryptionKey,\n    connectWallet,\n    disconnectWallet,\n    registerUser,\n    getEncryptionKey: getEncryptionKeyFromState,\n    validateEncryptionKey,\n    getStoredFiles,\n    storeFile,\n    uploadFile,\n    downloadFile: async (fileId: string, key: string) => {\n      // Implement download file logic here\n      console.log('Downloading file:', fileId, 'with key:', key);\n    },\n    deleteStoredFile,\n  };\n\n  return (\n    <WalletContext.Provider value={value}>\n      {children}\n    </WalletContext.Provider>\n  );\n};\n\nexport const useWallet = (): WalletContextType => {\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}