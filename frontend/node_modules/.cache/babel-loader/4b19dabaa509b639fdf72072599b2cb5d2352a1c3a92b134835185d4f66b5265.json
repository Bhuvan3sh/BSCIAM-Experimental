{"ast":null,"code":"var _jsxFileName = \"F:\\\\Final Year Project\\\\Project Implementation\\\\frontend\\\\src\\\\context\\\\WalletContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WalletContext = /*#__PURE__*/createContext(undefined);\nexport const WalletProvider = ({\n  children\n}) => {\n  _s();\n  const [wallet, setWallet] = useState({\n    isConnected: false,\n    account: null,\n    chainId: null,\n    balance: null\n  });\n  const [userProfile, setUserProfile] = useState(null);\n  const [isRegistered, setIsRegistered] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [encryptionKey, setEncryptionKey] = useState(null);\n  const [provider, setProvider] = useState(null);\n  const [signer, setSigner] = useState(null);\n\n  // Initialize encryption key for the current account\n  const initializeEncryptionKey = useCallback(account => {\n    const key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) return null;\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user\n  const getStoredFiles = useCallback(() => {\n    if (!wallet.account) return [];\n    const files = localStorage.getItem(`files_${wallet.account}`);\n    return files ? JSON.parse(files) : [];\n  }, [wallet.account]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback(() => {\n    if (!wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${wallet.account}`);\n  }, [wallet.account]);\n\n  // Store a new file\n  const storeFile = useCallback(file => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    const files = getStoredFiles();\n    // Check if file with same name already exists\n    const existingFileIndex = files.findIndex(f => f.name === file.name && f.uploadedAt === file.uploadedAt);\n    let updatedFiles;\n    if (existingFileIndex >= 0) {\n      // Update existing file\n      updatedFiles = [...files];\n      updatedFiles[existingFileIndex] = file;\n    } else {\n      // Add new file\n      updatedFiles = [...files, file];\n    }\n    localStorage.setItem(`files_${wallet.account}`, JSON.stringify(updatedFiles));\n    return updatedFiles;\n  }, [wallet.account, getStoredFiles]);\n\n  // Delete a file\n  const deleteStoredFile = useCallback(fileId => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    const files = getStoredFiles();\n    const fileToDelete = files.find(f => f.id === fileId);\n    if (!fileToDelete) {\n      throw new Error('File not found');\n    }\n    const updatedFiles = files.filter(file => file.id !== fileId);\n    localStorage.setItem(`files_${wallet.account}`, JSON.stringify(updatedFiles));\n    return updatedFiles;\n  }, [wallet.account, getStoredFiles]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback(() => {\n    return encryptionKey;\n  }, [encryptionKey]);\n\n  // Upload a file with encryption\n  const uploadFile = useCallback(async (file, encryptedData, key) => {\n    if (!wallet.account) return;\n    const storedFiles = getStoredFiles();\n    const newFile = {\n      id: crypto.randomUUID(),\n      name: file.name,\n      type: file.type,\n      size: file.size,\n      uploadedAt: new Date().toISOString(),\n      encryptedData,\n      metadata: {\n        name: file.name,\n        originalName: file.name,\n        type: file.type,\n        mimeType: file.type,\n        size: file.size,\n        lastModified: file.lastModified\n      }\n    };\n    const updatedFiles = [...storedFiles, newFile];\n    localStorage.setItem(`files_${wallet.account}`, JSON.stringify(updatedFiles));\n  }, [wallet.account, getStoredFiles]);\n\n  // Check if user is already registered\n  const checkRegistration = useCallback(async account => {\n    try {\n      const userData = localStorage.getItem(`user_${account}`);\n      if (userData) {\n        const userProfile = JSON.parse(userData);\n        const key = initializeEncryptionKey(account);\n        if (key) {\n          setUserProfile(userProfile);\n          setIsRegistered(true);\n          return true;\n        }\n      }\n      return false;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      setError('Failed to check user registration.');\n      return false;\n    }\n  }, [initializeEncryptionKey]);\n\n  // Validate encryption key against the stored key\n  const validateEncryptionKey = useCallback(key => {\n    if (!wallet.account) return false;\n    const storedKey = localStorage.getItem(`encryption_key_${wallet.account}`);\n    return key === storedKey;\n  }, [wallet.account]);\n\n  // Disconnect wallet\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setWallet({\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null\n    });\n    setUserProfile(null);\n    setIsRegistered(false);\n    setIsLoading(false);\n    setError(null);\n    setProvider(null);\n    setSigner(null);\n  }, []);\n\n  // Connect wallet\n  const connectWallet = useCallback(async () => {\n    if (typeof window.ethereum === 'undefined') {\n      setError('Please install MetaMask!');\n      return;\n    }\n    try {\n      setIsLoading(true);\n      const provider = new ethers.BrowserProvider(window.ethereum);\n      const signer = await provider.getSigner();\n      const address = await signer.getAddress();\n      const network = await provider.getNetwork();\n      setProvider(provider);\n      setSigner(signer);\n      setWallet({\n        isConnected: true,\n        account: address,\n        chainId: network.chainId.toString(),\n        balance: null\n      });\n      setError(null);\n\n      // Check if user is registered\n      await checkRegistration(address);\n    } catch (err) {\n      console.error('Error connecting wallet:', err);\n      setError('Failed to connect wallet. Please try again.');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [checkRegistration]);\n\n  // Register a new user\n  const registerUser = useCallback(async (username, email = '') => {\n    if (!wallet.account) {\n      return {\n        success: false,\n        message: 'No wallet connected'\n      };\n    }\n    try {\n      setIsLoading(true);\n\n      // Generate a secure encryption key for the user\n      const key = Array.from(window.crypto.getRandomValues(new Uint8Array(32))).map(b => b.toString(16).padStart(2, '0')).join('');\n\n      // Create user profile according to UserProfile interface\n      const newUserProfile = {\n        walletAddress: wallet.account,\n        username,\n        email,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n\n      // Store user data and encryption key in localStorage\n      localStorage.setItem(`user_${wallet.account}`, JSON.stringify(newUserProfile));\n      localStorage.setItem(`encryption_key_${wallet.account}`, key);\n\n      // Update state\n      setUserProfile(newUserProfile);\n      setIsRegistered(true);\n      setEncryptionKey(key);\n      return {\n        success: true,\n        message: 'Registration successful!'\n      };\n    } catch (error) {\n      console.error('Registration failed:', error);\n      return {\n        success: false,\n        message: error instanceof Error ? error.message : 'Registration failed. Please try again.'\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account]);\n  const value = {\n    wallet,\n    isRegistered,\n    userProfile,\n    isLoading,\n    error,\n    encryptionKey,\n    connectWallet,\n    disconnectWallet,\n    registerUser,\n    getEncryptionKey: getEncryptionKeyFromState,\n    validateEncryptionKey,\n    getStoredFiles,\n    storeFile,\n    uploadFile,\n    downloadFile: async (fileId, key) => {\n      // Implement download file logic here\n      console.log('Downloading file:', fileId, 'with key:', key);\n    },\n    deleteStoredFile\n  };\n  return /*#__PURE__*/_jsxDEV(WalletContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 321,\n    columnNumber: 5\n  }, this);\n};\n_s(WalletProvider, \"i2VwRhHvukgfLoMSEIzyExKz9Bo=\");\n_c = WalletProvider;\nexport const useWallet = () => {\n  _s2();\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\n_s2(useWallet, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"WalletProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","ethers","jsxDEV","_jsxDEV","WalletContext","undefined","WalletProvider","children","_s","wallet","setWallet","isConnected","account","chainId","balance","userProfile","setUserProfile","isRegistered","setIsRegistered","isLoading","setIsLoading","error","setError","encryptionKey","setEncryptionKey","provider","setProvider","signer","setSigner","initializeEncryptionKey","key","localStorage","getItem","getStoredFiles","files","JSON","parse","getEncryptionKey","storeFile","file","Error","existingFileIndex","findIndex","f","name","uploadedAt","updatedFiles","setItem","stringify","deleteStoredFile","fileId","fileToDelete","find","id","filter","getEncryptionKeyFromState","uploadFile","encryptedData","storedFiles","newFile","crypto","randomUUID","type","size","Date","toISOString","metadata","originalName","mimeType","lastModified","checkRegistration","userData","console","validateEncryptionKey","storedKey","disconnectWallet","connectWallet","window","ethereum","BrowserProvider","getSigner","address","getAddress","network","getNetwork","toString","err","registerUser","username","email","success","message","Array","from","getRandomValues","Uint8Array","map","b","padStart","join","newUserProfile","walletAddress","registrationTime","isActive","reputationScore","accessRoles","value","downloadFile","log","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useWallet","_s2","context","$RefreshReg$"],"sources":["F:/Final Year Project/Project Implementation/frontend/src/context/WalletContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';\nimport { ethers } from 'ethers';\nimport { StoredFile } from '../types';\nimport { UserProfile } from '../types';\n\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n\ninterface WalletState {\n  isConnected: boolean;\n  account: string | null;\n  chainId: string | null;\n  balance: string | null;\n}\n\ninterface WalletContextType {\n  // Wallet state\n  wallet: WalletState;\n  isRegistered: boolean;\n  userProfile: UserProfile | null;\n  isLoading: boolean;\n  error: string | null;\n  encryptionKey: string | null;\n  \n  // Wallet methods\n  connectWallet: () => Promise<void>;\n  disconnectWallet: () => void;\n  \n  // User methods\n  registerUser: (username: string) => Promise<{ success: boolean; message: string }>;\n  \n  // Encryption methods\n  getEncryptionKey: () => string | null;\n  validateEncryptionKey: (key: string) => boolean;\n  \n  // File methods\n  getStoredFiles: () => StoredFile[];\n  storeFile: (file: StoredFile) => StoredFile[];\n  uploadFile: (file: File, encryptedData: any, key: string) => Promise<void>;\n  downloadFile: (fileId: string, key: string) => Promise<void>;\n  deleteStoredFile: (fileId: string) => void;\n}\n\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\n\ninterface WalletProviderProps {\n  children: ReactNode;\n}\n\nexport const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {\n  const [wallet, setWallet] = useState<WalletState>({\n    isConnected: false,\n    account: null,\n    chainId: null,\n    balance: null,\n  });\n  \n  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);\n  const [isRegistered, setIsRegistered] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [encryptionKey, setEncryptionKey] = useState<string | null>(null);\n\n  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);\n  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);\n\n  // Initialize encryption key for the current account\n  const initializeEncryptionKey = useCallback((account: string): string | null => {\n    const key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) return null;\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user\n  const getStoredFiles = useCallback((): StoredFile[] => {\n    if (!wallet.account) return [];\n    const files = localStorage.getItem(`files_${wallet.account}`);\n    return files ? JSON.parse(files) : [];\n  }, [wallet.account]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback((): string | null => {\n    if (!wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${wallet.account}`);\n  }, [wallet.account]);\n\n  // Store a new file\n  const storeFile = useCallback((file: StoredFile) => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    // Check if file with same name already exists\n    const existingFileIndex = files.findIndex(f => f.name === file.name && f.uploadedAt === file.uploadedAt);\n    \n    let updatedFiles;\n    if (existingFileIndex >= 0) {\n      // Update existing file\n      updatedFiles = [...files];\n      updatedFiles[existingFileIndex] = file;\n    } else {\n      // Add new file\n      updatedFiles = [...files, file];\n    }\n    \n    localStorage.setItem(\n      `files_${wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [wallet.account, getStoredFiles]);\n\n  // Delete a file\n  const deleteStoredFile = useCallback((fileId: string) => {\n    if (!wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    const fileToDelete = files.find(f => f.id === fileId);\n    \n    if (!fileToDelete) {\n      throw new Error('File not found');\n    }\n    \n    const updatedFiles = files.filter(file => file.id !== fileId);\n    \n    localStorage.setItem(\n      `files_${wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [wallet.account, getStoredFiles]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback((): string | null => {\n    return encryptionKey;\n  }, [encryptionKey]);\n\n  // Upload a file with encryption\n  const uploadFile = useCallback(async (file: File, encryptedData: any, key: string): Promise<void> => {\n    if (!wallet.account) return;\n    \n    const storedFiles = getStoredFiles();\n    const newFile: StoredFile = {\n      id: crypto.randomUUID(),\n      name: file.name,\n      type: file.type,\n      size: file.size,\n      uploadedAt: new Date().toISOString(),\n      encryptedData,\n      metadata: {\n        name: file.name,\n        originalName: file.name,\n        type: file.type,\n        mimeType: file.type,\n        size: file.size,\n        lastModified: file.lastModified\n      }\n    };\n    \n    const updatedFiles = [...storedFiles, newFile];\n    localStorage.setItem(`files_${wallet.account}`, JSON.stringify(updatedFiles));\n  }, [wallet.account, getStoredFiles]);\n\n  // Check if user is already registered\n  const checkRegistration = useCallback(async (account: string): Promise<boolean> => {\n    try {\n      const userData = localStorage.getItem(`user_${account}`);\n      if (userData) {\n        const userProfile = JSON.parse(userData) as UserProfile;\n        const key = initializeEncryptionKey(account);\n        if (key) {\n          setUserProfile(userProfile);\n          setIsRegistered(true);\n          return true;\n        }\n      }\n      return false;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      setError('Failed to check user registration.');\n      return false;\n    }\n  }, [initializeEncryptionKey]);\n\n  // Validate encryption key against the stored key\n  const validateEncryptionKey = useCallback((key: string): boolean => {\n    if (!wallet.account) return false;\n    const storedKey = localStorage.getItem(`encryption_key_${wallet.account}`);\n    return key === storedKey;\n  }, [wallet.account]);\n\n  // Disconnect wallet\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setWallet({\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null,\n    });\n    setUserProfile(null);\n    setIsRegistered(false);\n    setIsLoading(false);\n    setError(null);\n    setProvider(null);\n    setSigner(null);\n  }, []);\n\n  // Connect wallet\n  const connectWallet = useCallback(async () => {\n    if (typeof window.ethereum === 'undefined') {\n      setError('Please install MetaMask!');\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      const provider = new ethers.BrowserProvider(window.ethereum);\n      const signer = await provider.getSigner();\n      const address = await signer.getAddress();\n      const network = await provider.getNetwork();\n      \n      setProvider(provider);\n      setSigner(signer);\n      setWallet({\n        isConnected: true,\n        account: address,\n        chainId: network.chainId.toString(),\n        balance: null,\n      });\n      setError(null);\n\n      // Check if user is registered\n      await checkRegistration(address);\n    } catch (err) {\n      console.error('Error connecting wallet:', err);\n      setError('Failed to connect wallet. Please try again.');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [checkRegistration]);\n\n  // Register a new user\n  const registerUser = useCallback(async (username: string, email: string = '') => {\n    if (!wallet.account) {\n      return { success: false, message: 'No wallet connected' };\n    }\n\n    try {\n      setIsLoading(true);\n      \n      // Generate a secure encryption key for the user\n      const key = Array.from(window.crypto.getRandomValues(new Uint8Array(32)))\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('');\n      \n      // Create user profile according to UserProfile interface\n      const newUserProfile: UserProfile = {\n        walletAddress: wallet.account,\n        username,\n        email,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n\n      // Store user data and encryption key in localStorage\n      localStorage.setItem(`user_${wallet.account}`, JSON.stringify(newUserProfile));\n      localStorage.setItem(`encryption_key_${wallet.account}`, key);\n      \n      // Update state\n      setUserProfile(newUserProfile);\n      setIsRegistered(true);\n      setEncryptionKey(key);\n      \n      return { success: true, message: 'Registration successful!' };\n    } catch (error) {\n      console.error('Registration failed:', error);\n      return { \n        success: false, \n        message: error instanceof Error ? error.message : 'Registration failed. Please try again.'\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [wallet.account]);\n\n  const value: WalletContextType = {\n    wallet,\n    isRegistered,\n    userProfile,\n    isLoading,\n    error,\n    encryptionKey,\n    connectWallet,\n    disconnectWallet,\n    registerUser,\n    getEncryptionKey: getEncryptionKeyFromState,\n    validateEncryptionKey,\n    getStoredFiles,\n    storeFile,\n    uploadFile,\n    downloadFile: async (fileId: string, key: string) => {\n      // Implement download file logic here\n      console.log('Downloading file:', fileId, 'with key:', key);\n    },\n    deleteStoredFile,\n  };\n\n  return (\n    <WalletContext.Provider value={value}>\n      {children}\n    </WalletContext.Provider>\n  );\n};\n\nexport const useWallet = (): WalletContextType => {\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n"],"mappings":";;;AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,WAAW,QAAmB,OAAO;AAC1F,SAASC,MAAM,QAAQ,QAAQ;AAAC,SAAAC,MAAA,IAAAC,OAAA;AA6ChC,MAAMC,aAAa,gBAAGP,aAAa,CAAgCQ,SAAS,CAAC;AAM7E,OAAO,MAAMC,cAA6C,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EAC7E,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGX,QAAQ,CAAc;IAChDY,WAAW,EAAE,KAAK;IAClBC,OAAO,EAAE,IAAI;IACbC,OAAO,EAAE,IAAI;IACbC,OAAO,EAAE;EACX,CAAC,CAAC;EAEF,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGjB,QAAQ,CAAqB,IAAI,CAAC;EACxE,MAAM,CAACkB,YAAY,EAAEC,eAAe,CAAC,GAAGnB,QAAQ,CAAC,KAAK,CAAC;EACvD,MAAM,CAACoB,SAAS,EAAEC,YAAY,CAAC,GAAGrB,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACsB,KAAK,EAAEC,QAAQ,CAAC,GAAGvB,QAAQ,CAAgB,IAAI,CAAC;EACvD,MAAM,CAACwB,aAAa,EAAEC,gBAAgB,CAAC,GAAGzB,QAAQ,CAAgB,IAAI,CAAC;EAEvE,MAAM,CAAC0B,QAAQ,EAAEC,WAAW,CAAC,GAAG3B,QAAQ,CAAgC,IAAI,CAAC;EAC7E,MAAM,CAAC4B,MAAM,EAAEC,SAAS,CAAC,GAAG7B,QAAQ,CAA8B,IAAI,CAAC;;EAEvE;EACA,MAAM8B,uBAAuB,GAAG7B,WAAW,CAAEY,OAAe,IAAoB;IAC9E,MAAMkB,GAAG,GAAGC,YAAY,CAACC,OAAO,CAAC,kBAAkBpB,OAAO,EAAE,CAAC;IAC7D,IAAI,CAACkB,GAAG,EAAE,OAAO,IAAI;IACrBN,gBAAgB,CAACM,GAAG,CAAC;IACrB,OAAOA,GAAG;EACZ,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMG,cAAc,GAAGjC,WAAW,CAAC,MAAoB;IACrD,IAAI,CAACS,MAAM,CAACG,OAAO,EAAE,OAAO,EAAE;IAC9B,MAAMsB,KAAK,GAAGH,YAAY,CAACC,OAAO,CAAC,SAASvB,MAAM,CAACG,OAAO,EAAE,CAAC;IAC7D,OAAOsB,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACF,KAAK,CAAC,GAAG,EAAE;EACvC,CAAC,EAAE,CAACzB,MAAM,CAACG,OAAO,CAAC,CAAC;;EAEpB;EACA,MAAMyB,gBAAgB,GAAGrC,WAAW,CAAC,MAAqB;IACxD,IAAI,CAACS,MAAM,CAACG,OAAO,EAAE,OAAO,IAAI;IAChC,OAAOmB,YAAY,CAACC,OAAO,CAAC,kBAAkBvB,MAAM,CAACG,OAAO,EAAE,CAAC;EACjE,CAAC,EAAE,CAACH,MAAM,CAACG,OAAO,CAAC,CAAC;;EAEpB;EACA,MAAM0B,SAAS,GAAGtC,WAAW,CAAEuC,IAAgB,IAAK;IAClD,IAAI,CAAC9B,MAAM,CAACG,OAAO,EAAE;MACnB,MAAM,IAAI4B,KAAK,CAAC,qBAAqB,CAAC;IACxC;IAEA,MAAMN,KAAK,GAAGD,cAAc,CAAC,CAAC;IAC9B;IACA,MAAMQ,iBAAiB,GAAGP,KAAK,CAACQ,SAAS,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,KAAKL,IAAI,CAACK,IAAI,IAAID,CAAC,CAACE,UAAU,KAAKN,IAAI,CAACM,UAAU,CAAC;IAExG,IAAIC,YAAY;IAChB,IAAIL,iBAAiB,IAAI,CAAC,EAAE;MAC1B;MACAK,YAAY,GAAG,CAAC,GAAGZ,KAAK,CAAC;MACzBY,YAAY,CAACL,iBAAiB,CAAC,GAAGF,IAAI;IACxC,CAAC,MAAM;MACL;MACAO,YAAY,GAAG,CAAC,GAAGZ,KAAK,EAAEK,IAAI,CAAC;IACjC;IAEAR,YAAY,CAACgB,OAAO,CAClB,SAAStC,MAAM,CAACG,OAAO,EAAE,EACzBuB,IAAI,CAACa,SAAS,CAACF,YAAY,CAC7B,CAAC;IAED,OAAOA,YAAY;EACrB,CAAC,EAAE,CAACrC,MAAM,CAACG,OAAO,EAAEqB,cAAc,CAAC,CAAC;;EAEpC;EACA,MAAMgB,gBAAgB,GAAGjD,WAAW,CAAEkD,MAAc,IAAK;IACvD,IAAI,CAACzC,MAAM,CAACG,OAAO,EAAE;MACnB,MAAM,IAAI4B,KAAK,CAAC,qBAAqB,CAAC;IACxC;IAEA,MAAMN,KAAK,GAAGD,cAAc,CAAC,CAAC;IAC9B,MAAMkB,YAAY,GAAGjB,KAAK,CAACkB,IAAI,CAACT,CAAC,IAAIA,CAAC,CAACU,EAAE,KAAKH,MAAM,CAAC;IAErD,IAAI,CAACC,YAAY,EAAE;MACjB,MAAM,IAAIX,KAAK,CAAC,gBAAgB,CAAC;IACnC;IAEA,MAAMM,YAAY,GAAGZ,KAAK,CAACoB,MAAM,CAACf,IAAI,IAAIA,IAAI,CAACc,EAAE,KAAKH,MAAM,CAAC;IAE7DnB,YAAY,CAACgB,OAAO,CAClB,SAAStC,MAAM,CAACG,OAAO,EAAE,EACzBuB,IAAI,CAACa,SAAS,CAACF,YAAY,CAC7B,CAAC;IAED,OAAOA,YAAY;EACrB,CAAC,EAAE,CAACrC,MAAM,CAACG,OAAO,EAAEqB,cAAc,CAAC,CAAC;;EAEpC;EACA,MAAMsB,yBAAyB,GAAGvD,WAAW,CAAC,MAAqB;IACjE,OAAOuB,aAAa;EACtB,CAAC,EAAE,CAACA,aAAa,CAAC,CAAC;;EAEnB;EACA,MAAMiC,UAAU,GAAGxD,WAAW,CAAC,OAAOuC,IAAU,EAAEkB,aAAkB,EAAE3B,GAAW,KAAoB;IACnG,IAAI,CAACrB,MAAM,CAACG,OAAO,EAAE;IAErB,MAAM8C,WAAW,GAAGzB,cAAc,CAAC,CAAC;IACpC,MAAM0B,OAAmB,GAAG;MAC1BN,EAAE,EAAEO,MAAM,CAACC,UAAU,CAAC,CAAC;MACvBjB,IAAI,EAAEL,IAAI,CAACK,IAAI;MACfkB,IAAI,EAAEvB,IAAI,CAACuB,IAAI;MACfC,IAAI,EAAExB,IAAI,CAACwB,IAAI;MACflB,UAAU,EAAE,IAAImB,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;MACpCR,aAAa;MACbS,QAAQ,EAAE;QACRtB,IAAI,EAAEL,IAAI,CAACK,IAAI;QACfuB,YAAY,EAAE5B,IAAI,CAACK,IAAI;QACvBkB,IAAI,EAAEvB,IAAI,CAACuB,IAAI;QACfM,QAAQ,EAAE7B,IAAI,CAACuB,IAAI;QACnBC,IAAI,EAAExB,IAAI,CAACwB,IAAI;QACfM,YAAY,EAAE9B,IAAI,CAAC8B;MACrB;IACF,CAAC;IAED,MAAMvB,YAAY,GAAG,CAAC,GAAGY,WAAW,EAAEC,OAAO,CAAC;IAC9C5B,YAAY,CAACgB,OAAO,CAAC,SAAStC,MAAM,CAACG,OAAO,EAAE,EAAEuB,IAAI,CAACa,SAAS,CAACF,YAAY,CAAC,CAAC;EAC/E,CAAC,EAAE,CAACrC,MAAM,CAACG,OAAO,EAAEqB,cAAc,CAAC,CAAC;;EAEpC;EACA,MAAMqC,iBAAiB,GAAGtE,WAAW,CAAC,MAAOY,OAAe,IAAuB;IACjF,IAAI;MACF,MAAM2D,QAAQ,GAAGxC,YAAY,CAACC,OAAO,CAAC,QAAQpB,OAAO,EAAE,CAAC;MACxD,IAAI2D,QAAQ,EAAE;QACZ,MAAMxD,WAAW,GAAGoB,IAAI,CAACC,KAAK,CAACmC,QAAQ,CAAgB;QACvD,MAAMzC,GAAG,GAAGD,uBAAuB,CAACjB,OAAO,CAAC;QAC5C,IAAIkB,GAAG,EAAE;UACPd,cAAc,CAACD,WAAW,CAAC;UAC3BG,eAAe,CAAC,IAAI,CAAC;UACrB,OAAO,IAAI;QACb;MACF;MACA,OAAO,KAAK;IACd,CAAC,CAAC,OAAOG,KAAK,EAAE;MACdmD,OAAO,CAACnD,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpDC,QAAQ,CAAC,oCAAoC,CAAC;MAC9C,OAAO,KAAK;IACd;EACF,CAAC,EAAE,CAACO,uBAAuB,CAAC,CAAC;;EAE7B;EACA,MAAM4C,qBAAqB,GAAGzE,WAAW,CAAE8B,GAAW,IAAc;IAClE,IAAI,CAACrB,MAAM,CAACG,OAAO,EAAE,OAAO,KAAK;IACjC,MAAM8D,SAAS,GAAG3C,YAAY,CAACC,OAAO,CAAC,kBAAkBvB,MAAM,CAACG,OAAO,EAAE,CAAC;IAC1E,OAAOkB,GAAG,KAAK4C,SAAS;EAC1B,CAAC,EAAE,CAACjE,MAAM,CAACG,OAAO,CAAC,CAAC;;EAEpB;EACA,MAAM+D,gBAAgB,GAAG3E,WAAW,CAAC,MAAM;IACzC;IACAU,SAAS,CAAC;MACRC,WAAW,EAAE,KAAK;MAClBC,OAAO,EAAE,IAAI;MACbC,OAAO,EAAE,IAAI;MACbC,OAAO,EAAE;IACX,CAAC,CAAC;IACFE,cAAc,CAAC,IAAI,CAAC;IACpBE,eAAe,CAAC,KAAK,CAAC;IACtBE,YAAY,CAAC,KAAK,CAAC;IACnBE,QAAQ,CAAC,IAAI,CAAC;IACdI,WAAW,CAAC,IAAI,CAAC;IACjBE,SAAS,CAAC,IAAI,CAAC;EACjB,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMgD,aAAa,GAAG5E,WAAW,CAAC,YAAY;IAC5C,IAAI,OAAO6E,MAAM,CAACC,QAAQ,KAAK,WAAW,EAAE;MAC1CxD,QAAQ,CAAC,0BAA0B,CAAC;MACpC;IACF;IAEA,IAAI;MACFF,YAAY,CAAC,IAAI,CAAC;MAClB,MAAMK,QAAQ,GAAG,IAAIxB,MAAM,CAAC8E,eAAe,CAACF,MAAM,CAACC,QAAQ,CAAC;MAC5D,MAAMnD,MAAM,GAAG,MAAMF,QAAQ,CAACuD,SAAS,CAAC,CAAC;MACzC,MAAMC,OAAO,GAAG,MAAMtD,MAAM,CAACuD,UAAU,CAAC,CAAC;MACzC,MAAMC,OAAO,GAAG,MAAM1D,QAAQ,CAAC2D,UAAU,CAAC,CAAC;MAE3C1D,WAAW,CAACD,QAAQ,CAAC;MACrBG,SAAS,CAACD,MAAM,CAAC;MACjBjB,SAAS,CAAC;QACRC,WAAW,EAAE,IAAI;QACjBC,OAAO,EAAEqE,OAAO;QAChBpE,OAAO,EAAEsE,OAAO,CAACtE,OAAO,CAACwE,QAAQ,CAAC,CAAC;QACnCvE,OAAO,EAAE;MACX,CAAC,CAAC;MACFQ,QAAQ,CAAC,IAAI,CAAC;;MAEd;MACA,MAAMgD,iBAAiB,CAACW,OAAO,CAAC;IAClC,CAAC,CAAC,OAAOK,GAAG,EAAE;MACZd,OAAO,CAACnD,KAAK,CAAC,0BAA0B,EAAEiE,GAAG,CAAC;MAC9ChE,QAAQ,CAAC,6CAA6C,CAAC;IACzD,CAAC,SAAS;MACRF,YAAY,CAAC,KAAK,CAAC;IACrB;EACF,CAAC,EAAE,CAACkD,iBAAiB,CAAC,CAAC;;EAEvB;EACA,MAAMiB,YAAY,GAAGvF,WAAW,CAAC,OAAOwF,QAAgB,EAAEC,KAAa,GAAG,EAAE,KAAK;IAC/E,IAAI,CAAChF,MAAM,CAACG,OAAO,EAAE;MACnB,OAAO;QAAE8E,OAAO,EAAE,KAAK;QAAEC,OAAO,EAAE;MAAsB,CAAC;IAC3D;IAEA,IAAI;MACFvE,YAAY,CAAC,IAAI,CAAC;;MAElB;MACA,MAAMU,GAAG,GAAG8D,KAAK,CAACC,IAAI,CAAChB,MAAM,CAACjB,MAAM,CAACkC,eAAe,CAAC,IAAIC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CACtEC,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACZ,QAAQ,CAAC,EAAE,CAAC,CAACa,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CACzCC,IAAI,CAAC,EAAE,CAAC;;MAEX;MACA,MAAMC,cAA2B,GAAG;QAClCC,aAAa,EAAE5F,MAAM,CAACG,OAAO;QAC7B4E,QAAQ;QACRC,KAAK;QACLa,gBAAgB,EAAE,IAAItC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;QAC1CsC,QAAQ,EAAE,IAAI;QACdC,eAAe,EAAE,CAAC;QAClBC,WAAW,EAAE,CAAC,MAAM;MACtB,CAAC;;MAED;MACA1E,YAAY,CAACgB,OAAO,CAAC,QAAQtC,MAAM,CAACG,OAAO,EAAE,EAAEuB,IAAI,CAACa,SAAS,CAACoD,cAAc,CAAC,CAAC;MAC9ErE,YAAY,CAACgB,OAAO,CAAC,kBAAkBtC,MAAM,CAACG,OAAO,EAAE,EAAEkB,GAAG,CAAC;;MAE7D;MACAd,cAAc,CAACoF,cAAc,CAAC;MAC9BlF,eAAe,CAAC,IAAI,CAAC;MACrBM,gBAAgB,CAACM,GAAG,CAAC;MAErB,OAAO;QAAE4D,OAAO,EAAE,IAAI;QAAEC,OAAO,EAAE;MAA2B,CAAC;IAC/D,CAAC,CAAC,OAAOtE,KAAK,EAAE;MACdmD,OAAO,CAACnD,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;MAC5C,OAAO;QACLqE,OAAO,EAAE,KAAK;QACdC,OAAO,EAAEtE,KAAK,YAAYmB,KAAK,GAAGnB,KAAK,CAACsE,OAAO,GAAG;MACpD,CAAC;IACH,CAAC,SAAS;MACRvE,YAAY,CAAC,KAAK,CAAC;IACrB;EACF,CAAC,EAAE,CAACX,MAAM,CAACG,OAAO,CAAC,CAAC;EAEpB,MAAM8F,KAAwB,GAAG;IAC/BjG,MAAM;IACNQ,YAAY;IACZF,WAAW;IACXI,SAAS;IACTE,KAAK;IACLE,aAAa;IACbqD,aAAa;IACbD,gBAAgB;IAChBY,YAAY;IACZlD,gBAAgB,EAAEkB,yBAAyB;IAC3CkB,qBAAqB;IACrBxC,cAAc;IACdK,SAAS;IACTkB,UAAU;IACVmD,YAAY,EAAE,MAAAA,CAAOzD,MAAc,EAAEpB,GAAW,KAAK;MACnD;MACA0C,OAAO,CAACoC,GAAG,CAAC,mBAAmB,EAAE1D,MAAM,EAAE,WAAW,EAAEpB,GAAG,CAAC;IAC5D,CAAC;IACDmB;EACF,CAAC;EAED,oBACE9C,OAAA,CAACC,aAAa,CAACyG,QAAQ;IAACH,KAAK,EAAEA,KAAM;IAAAnG,QAAA,EAClCA;EAAQ;IAAAuG,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACa,CAAC;AAE7B,CAAC;AAACzG,EAAA,CAhRWF,cAA6C;AAAA4G,EAAA,GAA7C5G,cAA6C;AAkR1D,OAAO,MAAM6G,SAAS,GAAGA,CAAA,KAAyB;EAAAC,GAAA;EAChD,MAAMC,OAAO,GAAGvH,UAAU,CAACM,aAAa,CAAC;EACzC,IAAIiH,OAAO,KAAKhH,SAAS,EAAE;IACzB,MAAM,IAAImC,KAAK,CAAC,gDAAgD,CAAC;EACnE;EACA,OAAO6E,OAAO;AAChB,CAAC;;AAED;AAAAD,GAAA,CARaD,SAAS;AAAA,IAAAD,EAAA;AAAAI,YAAA,CAAAJ,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}