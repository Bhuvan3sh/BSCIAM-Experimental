{"ast":null,"code":"var _jsxFileName = \"F:\\\\Final Year Project\\\\Project Implementation\\\\frontend\\\\src\\\\context\\\\WalletContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WalletContext = /*#__PURE__*/createContext(undefined);\nexport const WalletProvider = ({\n  children\n}) => {\n  _s();\n  const [state, setState] = useState({\n    wallet: {\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null\n    },\n    userProfile: null,\n    isRegistered: false,\n    isLoading: false,\n    error: null\n  });\n  const [provider, setProvider] = useState(null);\n  const [signer, setSigner] = useState(null);\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setState({\n      wallet: {\n        isConnected: false,\n        account: null,\n        chainId: null,\n        balance: null\n      },\n      userProfile: null,\n      isRegistered: false,\n      isLoading: false,\n      error: null\n    });\n    setProvider(null);\n    setSigner(null);\n  }, []);\n  const connectWallet = useCallback(async () => {\n    try {\n      setState(prev => ({\n        ...prev,\n        isLoading: true,\n        error: null\n      }));\n      if (typeof window.ethereum === 'undefined') {\n        throw new Error('MetaMask is not installed');\n      }\n      const newProvider = new ethers.BrowserProvider(window.ethereum);\n      setProvider(newProvider);\n      const accounts = await window.ethereum.request({\n        method: 'eth_requestAccounts'\n      });\n      if (accounts.length === 0) {\n        throw new Error('No accounts found');\n      }\n      const newSigner = await newProvider.getSigner();\n      setSigner(newSigner);\n      const network = await newProvider.getNetwork();\n      const balance = await newProvider.getBalance(accounts[0]);\n      setState(prev => ({\n        ...prev,\n        wallet: {\n          isConnected: true,\n          account: accounts[0],\n          chainId: network.chainId.toString(),\n          balance: ethers.formatEther(balance)\n        },\n        isLoading: false\n      }));\n\n      // Check if user is registered and load their data\n      await checkRegistration();\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: error.message || 'Failed to connect wallet'\n      }));\n    }\n  }, [checkRegistration]);\n  const handleAccountsChanged = useCallback(accounts => {\n    if (accounts.length === 0) {\n      disconnectWallet();\n    } else {\n      connectWallet();\n    }\n  }, [connectWallet, disconnectWallet]);\n  const handleChainChanged = useCallback(() => {\n    window.location.reload();\n  }, []);\n  useEffect(() => {\n    const initWallet = async () => {\n      if (typeof window.ethereum !== 'undefined') {\n        const newProvider = new ethers.BrowserProvider(window.ethereum);\n        setProvider(newProvider);\n\n        // Check if already connected\n        try {\n          const accounts = await window.ethereum.request({\n            method: 'eth_accounts'\n          });\n          if (accounts.length > 0) {\n            await connectWallet();\n          }\n        } catch (error) {\n          console.error('Error checking existing connection:', error);\n        }\n\n        // Listen for account changes\n        window.ethereum.on('accountsChanged', handleAccountsChanged);\n        window.ethereum.on('chainChanged', handleChainChanged);\n      }\n    };\n    initWallet();\n    return () => {\n      if (window.ethereum) {\n        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);\n        window.ethereum.removeListener('chainChanged', handleChainChanged);\n      }\n    };\n  }, [connectWallet, handleAccountsChanged, handleChainChanged]);\n  const checkRegistration = useCallback(async () => {\n    if (!state.wallet.account) return false;\n    try {\n      // Check if user is registered\n      const isRegistered = localStorage.getItem(`registered_${state.wallet.account}`) === 'true';\n      if (isRegistered) {\n        // Load stored user data\n        const storedUserData = localStorage.getItem(`userData_${state.wallet.account}`);\n        if (storedUserData) {\n          const userProfile = JSON.parse(storedUserData);\n          setState(prev => ({\n            ...prev,\n            isRegistered,\n            userProfile\n          }));\n        } else {\n          setState(prev => ({\n            ...prev,\n            isRegistered\n          }));\n        }\n      } else {\n        setState(prev => ({\n          ...prev,\n          isRegistered: false,\n          userProfile: null\n        }));\n      }\n      return isRegistered;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      return false;\n    }\n  }, [state.wallet.account]);\n  const registerUser = useCallback(async (username, email) => {\n    if (!provider || !signer || !state.wallet.account) {\n      throw new Error('Wallet not connected');\n    }\n    try {\n      setState(prev => ({\n        ...prev,\n        isLoading: true,\n        error: null\n      }));\n\n      // This would be implemented with actual contract calls\n      // For now, we'll simulate registration\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      // Store registration status\n      localStorage.setItem(`registered_${state.wallet.account}`, 'true');\n      const userProfile = {\n        walletAddress: state.wallet.account,\n        username,\n        email,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 100,\n        accessRoles: []\n      };\n\n      // Store user data for future logins\n      localStorage.setItem(`userData_${state.wallet.account}`, JSON.stringify(userProfile));\n      setState(prev => ({\n        ...prev,\n        userProfile,\n        isRegistered: true,\n        isLoading: false\n      }));\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: error.message || 'Registration failed'\n      }));\n      throw error;\n    }\n  }, [provider, signer, state.wallet.account]);\n  const clearUserData = useCallback(() => {\n    if (state.wallet.account) {\n      localStorage.removeItem(`registered_${state.wallet.account}`);\n      localStorage.removeItem(`userData_${state.wallet.account}`);\n      setState(prev => ({\n        ...prev,\n        isRegistered: false,\n        userProfile: null\n      }));\n    }\n  }, [state.wallet.account]);\n  const value = {\n    state,\n    connectWallet,\n    disconnectWallet,\n    checkRegistration,\n    registerUser,\n    clearUserData\n  };\n  return /*#__PURE__*/_jsxDEV(WalletContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 251,\n    columnNumber: 5\n  }, this);\n};\n_s(WalletProvider, \"kP5whJCDq1e8GgH3iZQSiTxpdS8=\");\n_c = WalletProvider;\nexport const useWallet = () => {\n  _s2();\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\n_s2(useWallet, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"WalletProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","useCallback","ethers","jsxDEV","_jsxDEV","WalletContext","undefined","WalletProvider","children","_s","state","setState","wallet","isConnected","account","chainId","balance","userProfile","isRegistered","isLoading","error","provider","setProvider","signer","setSigner","disconnectWallet","connectWallet","prev","window","ethereum","Error","newProvider","BrowserProvider","accounts","request","method","length","newSigner","getSigner","network","getNetwork","getBalance","toString","formatEther","checkRegistration","message","handleAccountsChanged","handleChainChanged","location","reload","initWallet","console","on","removeListener","localStorage","getItem","storedUserData","JSON","parse","registerUser","username","email","Promise","resolve","setTimeout","setItem","walletAddress","registrationTime","Date","toISOString","isActive","reputationScore","accessRoles","stringify","clearUserData","removeItem","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useWallet","_s2","context","$RefreshReg$"],"sources":["F:/Final Year Project/Project Implementation/frontend/src/context/WalletContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, ReactNode, useCallback } from 'react';\r\nimport { ethers } from 'ethers';\r\nimport { AppState, UserProfile } from '../types';\r\n\r\ninterface WalletContextType {\r\n  state: AppState;\r\n  connectWallet: () => Promise<void>;\r\n  disconnectWallet: () => void;\r\n  checkRegistration: () => Promise<boolean>;\r\n  registerUser: (username: string, email: string) => Promise<void>;\r\n  clearUserData: () => void;\r\n}\r\n\r\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\r\n\r\ninterface WalletProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\nexport const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {\r\n  const [state, setState] = useState<AppState>({\r\n    wallet: {\r\n      isConnected: false,\r\n      account: null,\r\n      chainId: null,\r\n      balance: null,\r\n    },\r\n    userProfile: null,\r\n    isRegistered: false,\r\n    isLoading: false,\r\n    error: null,\r\n  });\r\n\r\n  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);\r\n  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);\r\n\r\n  const disconnectWallet = useCallback(() => {\r\n    // Note: We don't clear localStorage here to preserve user data for future logins\r\n    setState({\r\n      wallet: {\r\n        isConnected: false,\r\n        account: null,\r\n        chainId: null,\r\n        balance: null,\r\n      },\r\n      userProfile: null,\r\n      isRegistered: false,\r\n      isLoading: false,\r\n      error: null,\r\n    });\r\n    setProvider(null);\r\n    setSigner(null);\r\n  }, []);\r\n\r\n  const connectWallet = useCallback(async () => {\r\n    try {\r\n      setState(prev => ({ ...prev, isLoading: true, error: null }));\r\n\r\n      if (typeof window.ethereum === 'undefined') {\r\n        throw new Error('MetaMask is not installed');\r\n      }\r\n\r\n      const newProvider = new ethers.BrowserProvider(window.ethereum);\r\n      setProvider(newProvider);\r\n\r\n      const accounts = await window.ethereum.request({\r\n        method: 'eth_requestAccounts',\r\n      });\r\n\r\n      if (accounts.length === 0) {\r\n        throw new Error('No accounts found');\r\n      }\r\n\r\n      const newSigner = await newProvider.getSigner();\r\n      setSigner(newSigner);\r\n\r\n      const network = await newProvider.getNetwork();\r\n      const balance = await newProvider.getBalance(accounts[0]);\r\n\r\n      setState(prev => ({\r\n        ...prev,\r\n        wallet: {\r\n          isConnected: true,\r\n          account: accounts[0],\r\n          chainId: network.chainId.toString(),\r\n          balance: ethers.formatEther(balance),\r\n        },\r\n        isLoading: false,\r\n      }));\r\n\r\n      // Check if user is registered and load their data\r\n      await checkRegistration();\r\n    } catch (error: any) {\r\n      setState(prev => ({\r\n        ...prev,\r\n        isLoading: false,\r\n        error: error.message || 'Failed to connect wallet',\r\n      }));\r\n    }\r\n  }, [checkRegistration]);\r\n\r\n  const handleAccountsChanged = useCallback((accounts: string[]) => {\r\n    if (accounts.length === 0) {\r\n      disconnectWallet();\r\n    } else {\r\n      connectWallet();\r\n    }\r\n  }, [connectWallet, disconnectWallet]);\r\n\r\n  const handleChainChanged = useCallback(() => {\r\n    window.location.reload();\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const initWallet = async () => {\r\n      if (typeof window.ethereum !== 'undefined') {\r\n        const newProvider = new ethers.BrowserProvider(window.ethereum);\r\n        setProvider(newProvider);\r\n\r\n        // Check if already connected\r\n        try {\r\n          const accounts = await window.ethereum.request({ method: 'eth_accounts' });\r\n          if (accounts.length > 0) {\r\n            await connectWallet();\r\n          }\r\n        } catch (error) {\r\n          console.error('Error checking existing connection:', error);\r\n        }\r\n\r\n        // Listen for account changes\r\n        window.ethereum.on('accountsChanged', handleAccountsChanged);\r\n        window.ethereum.on('chainChanged', handleChainChanged);\r\n      }\r\n    };\r\n\r\n    initWallet();\r\n\r\n    return () => {\r\n      if (window.ethereum) {\r\n        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);\r\n        window.ethereum.removeListener('chainChanged', handleChainChanged);\r\n      }\r\n    };\r\n  }, [connectWallet, handleAccountsChanged, handleChainChanged]);\r\n\r\n\r\n  const checkRegistration = useCallback(async (): Promise<boolean> => {\r\n    if (!state.wallet.account) return false;\r\n\r\n    try {\r\n      // Check if user is registered\r\n      const isRegistered = localStorage.getItem(`registered_${state.wallet.account}`) === 'true';\r\n      \r\n      if (isRegistered) {\r\n        // Load stored user data\r\n        const storedUserData = localStorage.getItem(`userData_${state.wallet.account}`);\r\n        if (storedUserData) {\r\n          const userProfile: UserProfile = JSON.parse(storedUserData);\r\n          setState(prev => ({\r\n            ...prev,\r\n            isRegistered,\r\n            userProfile,\r\n          }));\r\n        } else {\r\n          setState(prev => ({\r\n            ...prev,\r\n            isRegistered,\r\n          }));\r\n        }\r\n      } else {\r\n        setState(prev => ({\r\n          ...prev,\r\n          isRegistered: false,\r\n          userProfile: null,\r\n        }));\r\n      }\r\n\r\n      return isRegistered;\r\n    } catch (error) {\r\n      console.error('Error checking registration:', error);\r\n      return false;\r\n    }\r\n  }, [state.wallet.account]);\r\n\r\n  const registerUser = useCallback(async (username: string, email: string) => {\r\n    if (!provider || !signer || !state.wallet.account) {\r\n      throw new Error('Wallet not connected');\r\n    }\r\n\r\n    try {\r\n      setState(prev => ({ ...prev, isLoading: true, error: null }));\r\n\r\n      // This would be implemented with actual contract calls\r\n      // For now, we'll simulate registration\r\n      await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n      // Store registration status\r\n      localStorage.setItem(`registered_${state.wallet.account}`, 'true');\r\n      \r\n      const userProfile: UserProfile = {\r\n        walletAddress: state.wallet.account,\r\n        username,\r\n        email,\r\n        registrationTime: new Date().toISOString(),\r\n        isActive: true,\r\n        reputationScore: 100,\r\n        accessRoles: [],\r\n      };\r\n\r\n      // Store user data for future logins\r\n      localStorage.setItem(`userData_${state.wallet.account}`, JSON.stringify(userProfile));\r\n\r\n      setState(prev => ({\r\n        ...prev,\r\n        userProfile,\r\n        isRegistered: true,\r\n        isLoading: false,\r\n      }));\r\n    } catch (error: any) {\r\n      setState(prev => ({\r\n        ...prev,\r\n        isLoading: false,\r\n        error: error.message || 'Registration failed',\r\n      }));\r\n      throw error;\r\n    }\r\n  }, [provider, signer, state.wallet.account]);\r\n\r\n  const clearUserData = useCallback(() => {\r\n    if (state.wallet.account) {\r\n      localStorage.removeItem(`registered_${state.wallet.account}`);\r\n      localStorage.removeItem(`userData_${state.wallet.account}`);\r\n      setState(prev => ({\r\n        ...prev,\r\n        isRegistered: false,\r\n        userProfile: null,\r\n      }));\r\n    }\r\n  }, [state.wallet.account]);\r\n\r\n  const value: WalletContextType = {\r\n    state,\r\n    connectWallet,\r\n    disconnectWallet,\r\n    checkRegistration,\r\n    registerUser,\r\n    clearUserData,\r\n  };\r\n\r\n  return (\r\n    <WalletContext.Provider value={value}>\r\n      {children}\r\n    </WalletContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useWallet = (): WalletContextType => {\r\n  const context = useContext(WalletContext);\r\n  if (context === undefined) {\r\n    throw new Error('useWallet must be used within a WalletProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n// Extend Window interface for TypeScript\r\ndeclare global {\r\n  interface Window {\r\n    ethereum?: any;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}