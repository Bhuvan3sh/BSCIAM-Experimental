{"ast":null,"code":"import _objectSpread from\"F:/Final Year Project/Project Implementation/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useState,useCallback}from'react';import{ethers}from'ethers';import{generateEncryptionKey}from'../utils/cryptoUtils';import{jsx as _jsx}from\"react/jsx-runtime\";const WalletContext=/*#__PURE__*/createContext(undefined);export const WalletProvider=_ref=>{let{children}=_ref;const[state,setState]=useState({wallet:{isConnected:false,account:null,chainId:null,balance:null},userProfile:null,isRegistered:false,isLoading:false,error:null});const[provider,setProvider]=useState(null);const[signer,setSigner]=useState(null);const[encryptionKey,setEncryptionKey]=useState(null);// Initialize or get encryption key for the user\nconst initializeEncryptionKey=useCallback(account=>{let key=localStorage.getItem(\"encryption_key_\".concat(account));if(!key){// Generate a new encryption key if none exists\nkey=generateEncryptionKey();localStorage.setItem(\"encryption_key_\".concat(account),key);}setEncryptionKey(key);return key;},[]);// Get stored files for the current user\nconst getStoredFiles=useCallback(()=>{if(!state.wallet.account)return[];const storedFiles=localStorage.getItem(\"user_files_\".concat(state.wallet.account));return storedFiles?JSON.parse(storedFiles):[];},[state.wallet.account]);// Get the user's encryption key\nconst getEncryptionKey=useCallback(()=>{if(!state.wallet.account)return null;return localStorage.getItem(\"encryption_key_\".concat(state.wallet.account));},[state.wallet.account]);// Store a new file\nconst storeFile=useCallback(file=>{if(!state.wallet.account){throw new Error('No wallet connected');}const files=getStoredFiles();// Check if file with same name already exists\nconst existingFileIndex=files.findIndex(f=>f.name===file.name&&f.uploadedAt===file.uploadedAt);let updatedFiles;if(existingFileIndex>=0){// Update existing file\nupdatedFiles=[...files];updatedFiles[existingFileIndex]=file;}else{// Add new file\nupdatedFiles=[...files,file];}localStorage.setItem(\"user_files_\".concat(state.wallet.account),JSON.stringify(updatedFiles));return updatedFiles;},[state.wallet.account,getStoredFiles]);// Delete a file\nconst deleteStoredFile=useCallback(fileId=>{if(!state.wallet.account){throw new Error('No wallet connected');}const files=getStoredFiles();const fileToDelete=files.find(f=>f.id===fileId);if(!fileToDelete){throw new Error('File not found');}const updatedFiles=files.filter(file=>file.id!==fileId);localStorage.setItem(\"user_files_\".concat(state.wallet.account),JSON.stringify(updatedFiles));return updatedFiles;},[state.wallet.account,getStoredFiles]);// Get the current encryption key\nconst getEncryptionKeyFromState=useCallback(()=>{return encryptionKey;},[encryptionKey]);const checkRegistration=useCallback(async()=>{if(!state.wallet.account){console.log('checkRegistration: No wallet account');return false;}try{// Check if user is registered\nconst isRegistered=localStorage.getItem(\"registered_\".concat(state.wallet.account))==='true';console.log('checkRegistration: isRegistered =',isRegistered,'for account:',state.wallet.account);if(isRegistered){// Initialize encryption key for the user\ninitializeEncryptionKey(state.wallet.account);// Load stored user data\nconst storedUserData=localStorage.getItem(\"userData_\".concat(state.wallet.account));console.log('checkRegistration: storedUserData =',storedUserData);if(storedUserData){const userProfile=JSON.parse(storedUserData);setState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered,userProfile}));console.log('checkRegistration: Loaded user profile:',userProfile);}else{setState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered}));}}else{console.log('checkRegistration: User not registered, setting isRegistered to false');setState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered:false,userProfile:null}));}return isRegistered;}catch(error){console.error('Error checking registration:',error);return false;}},[state.wallet.account]);const disconnectWallet=useCallback(()=>{// Note: We don't clear localStorage here to preserve user data for future logins\nsetState({wallet:{isConnected:false,account:null,chainId:null,balance:null},userProfile:null,isRegistered:false,isLoading:false,error:null});setProvider(null);setSigner(null);},[]);const connectWallet=useCallback(async()=>{if(!window.ethereum){setState(prev=>_objectSpread(_objectSpread({},prev),{},{error:'Please install MetaMask to use this application!'}));return;}try{setState(prev=>_objectSpread(_objectSpread({},prev),{},{isLoading:true,error:null}));// Request account access\nconst accounts=await window.ethereum.request({method:'eth_requestAccounts'});const account=accounts[0];// Get the current network\nconst newProvider=new ethers.BrowserProvider(window.ethereum);const network=await newProvider.getNetwork();const balance=await newProvider.getBalance(account);const newSigner=await newProvider.getSigner();setProvider(newProvider);setSigner(newSigner);// Initialize encryption key for the user\ninitializeEncryptionKey(account);// Update state\nsetState(prev=>_objectSpread(_objectSpread({},prev),{},{wallet:{isConnected:true,account,chainId:network.chainId.toString(),balance:ethers.formatEther(balance)},isLoading:false}));// Check if user is registered\nawait checkRegistration();}catch(error){console.error('Error connecting wallet:',error);setState(prev=>_objectSpread(_objectSpread({},prev),{},{isLoading:false,error:'Failed to connect wallet. Please try again.'}));}},[checkRegistration,initializeEncryptionKey]);const handleAccountsChanged=useCallback(accounts=>{if(accounts.length===0){disconnectWallet();}else{connectWallet();}},[connectWallet,disconnectWallet]);const clearUserData=useCallback(()=>{if(state.wallet.account){localStorage.removeItem(\"user_\".concat(state.wallet.account));// Don't remove the encryption key or files on logout\n// This allows users to access their files when they log back in\n}setState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered:false,userProfile:null,error:null}));},[state.wallet.account]);const registerUser=useCallback(async(username,email)=>{console.log('registerUser called with:',{username,email,account:state.wallet.account});if(!provider||!signer||!state.wallet.account){console.error('registerUser: Wallet not connected',{provider:!!provider,signer:!!signer,account:state.wallet.account});throw new Error('Wallet not connected');}try{setState(prev=>_objectSpread(_objectSpread({},prev),{},{isLoading:true,error:null}));const userProfile={username,email,walletAddress:state.wallet.account,registrationTime:new Date().toISOString(),isActive:true,reputationScore:0,accessRoles:['user']};// Update state\nsetState(prev=>_objectSpread(_objectSpread({},prev),{},{isRegistered:true,userProfile,isLoading:false,error:null}));// Save to localStorage\nlocalStorage.setItem(\"user_\".concat(state.wallet.account),JSON.stringify(userProfile));// Generate and store encryption key if it doesn't exist\nif(!localStorage.getItem(\"encryption_key_\".concat(state.wallet.account))){const key=generateEncryptionKey();localStorage.setItem(\"encryption_key_\".concat(state.wallet.account),key);// In a real app, you would show this to the user and ask them to save it\nalert(\"IMPORTANT: Your encryption key is: \".concat(key,\"\\n\\nPlease save this key in a secure place. You will need it to access your files.\"));}return true;}catch(error){console.error('Registration failed:',error);setState(prev=>_objectSpread(_objectSpread({},prev),{},{isLoading:false,error:'Failed to register user. Please try again.'}));return false;}},[provider,signer,state.wallet.account]);const value={state,connectWallet,disconnectWallet,checkRegistration,registerUser,clearUserData,getEncryptionKey:getEncryptionKeyFromState,getStoredFiles,storeFile,deleteStoredFile:deleteStoredFile,getEncryptionKeyFromState};return/*#__PURE__*/_jsx(WalletContext.Provider,{value:value,children:children});};export const useWallet=()=>{const context=useContext(WalletContext);if(context===undefined){throw new Error('useWallet must be used within a WalletProvider');}return context;};// Extend Window interface for TypeScript","map":{"version":3,"names":["React","createContext","useContext","useState","useCallback","ethers","generateEncryptionKey","jsx","_jsx","WalletContext","undefined","WalletProvider","_ref","children","state","setState","wallet","isConnected","account","chainId","balance","userProfile","isRegistered","isLoading","error","provider","setProvider","signer","setSigner","encryptionKey","setEncryptionKey","initializeEncryptionKey","key","localStorage","getItem","concat","setItem","getStoredFiles","storedFiles","JSON","parse","getEncryptionKey","storeFile","file","Error","files","existingFileIndex","findIndex","f","name","uploadedAt","updatedFiles","stringify","deleteStoredFile","fileId","fileToDelete","find","id","filter","getEncryptionKeyFromState","checkRegistration","console","log","storedUserData","prev","_objectSpread","disconnectWallet","connectWallet","window","ethereum","accounts","request","method","newProvider","BrowserProvider","network","getNetwork","getBalance","newSigner","getSigner","toString","formatEther","handleAccountsChanged","length","clearUserData","removeItem","registerUser","username","email","walletAddress","registrationTime","Date","toISOString","isActive","reputationScore","accessRoles","alert","value","Provider","useWallet","context"],"sources":["F:/Final Year Project/Project Implementation/frontend/src/context/WalletContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';\nimport { ethers } from 'ethers';\nimport { StoredFile } from '../components/files/FileList';\nimport { AppState, UserProfile } from '../types';\nimport { generateEncryptionKey } from '../utils/cryptoUtils';\n\ninterface WalletContextType {\n  state: AppState;\n  connectWallet: () => Promise<void>;\n  disconnectWallet: () => void;\n  checkRegistration: () => Promise<boolean>;\n  registerUser: (username: string, email: string) => Promise<boolean>;\n  clearUserData: () => void;\n  getEncryptionKey: () => string | null;\n  getStoredFiles: () => StoredFile[];\n  storeFile: (file: StoredFile) => StoredFile[] | undefined;\n  deleteStoredFile: (fileId: string) => StoredFile[];\n  getEncryptionKeyFromState: () => string | null;\n}\n\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\n\ninterface WalletProviderProps {\n  children: ReactNode;\n}\n\nexport const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {\n  const [state, setState] = useState<AppState>({\n    wallet: {\n      isConnected: false,\n      account: null,\n      chainId: null,\n      balance: null,\n    },\n    userProfile: null,\n    isRegistered: false,\n    isLoading: false,\n    error: null,\n  });\n\n  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);\n  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);\n  const [encryptionKey, setEncryptionKey] = useState<string | null>(null);\n\n  // Initialize or get encryption key for the user\n  const initializeEncryptionKey = useCallback((account: string) => {\n    let key = localStorage.getItem(`encryption_key_${account}`);\n    if (!key) {\n      // Generate a new encryption key if none exists\n      key = generateEncryptionKey();\n      localStorage.setItem(`encryption_key_${account}`, key);\n    }\n    setEncryptionKey(key);\n    return key;\n  }, []);\n\n  // Get stored files for the current user\n  const getStoredFiles = useCallback((): StoredFile[] => {\n    if (!state.wallet.account) return [];\n    const storedFiles = localStorage.getItem(`user_files_${state.wallet.account}`);\n    return storedFiles ? JSON.parse(storedFiles) : [];\n  }, [state.wallet.account]);\n\n  // Get the user's encryption key\n  const getEncryptionKey = useCallback((): string | null => {\n    if (!state.wallet.account) return null;\n    return localStorage.getItem(`encryption_key_${state.wallet.account}`);\n  }, [state.wallet.account]);\n\n  // Store a new file\n  const storeFile = useCallback((file: StoredFile) => {\n    if (!state.wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    // Check if file with same name already exists\n    const existingFileIndex = files.findIndex(f => f.name === file.name && f.uploadedAt === file.uploadedAt);\n    \n    let updatedFiles;\n    if (existingFileIndex >= 0) {\n      // Update existing file\n      updatedFiles = [...files];\n      updatedFiles[existingFileIndex] = file;\n    } else {\n      // Add new file\n      updatedFiles = [...files, file];\n    }\n    \n    localStorage.setItem(\n      `user_files_${state.wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [state.wallet.account, getStoredFiles]);\n\n  // Delete a file\n  const deleteStoredFile = useCallback((fileId: string) => {\n    if (!state.wallet.account) {\n      throw new Error('No wallet connected');\n    }\n    \n    const files = getStoredFiles();\n    const fileToDelete = files.find(f => f.id === fileId);\n    \n    if (!fileToDelete) {\n      throw new Error('File not found');\n    }\n    \n    const updatedFiles = files.filter(file => file.id !== fileId);\n    \n    localStorage.setItem(\n      `user_files_${state.wallet.account}`, \n      JSON.stringify(updatedFiles)\n    );\n    \n    return updatedFiles;\n  }, [state.wallet.account, getStoredFiles]);\n\n  // Get the current encryption key\n  const getEncryptionKeyFromState = useCallback((): string | null => {\n    return encryptionKey;\n  }, [encryptionKey]);\n\n  const checkRegistration = useCallback(async (): Promise<boolean> => {\n    if (!state.wallet.account) {\n      console.log('checkRegistration: No wallet account');\n      return false;\n    }\n\n    try {\n      // Check if user is registered\n      const isRegistered = localStorage.getItem(`registered_${state.wallet.account}`) === 'true';\n      console.log('checkRegistration: isRegistered =', isRegistered, 'for account:', state.wallet.account);\n      \n      if (isRegistered) {\n        // Initialize encryption key for the user\n        initializeEncryptionKey(state.wallet.account);\n        \n        // Load stored user data\n        const storedUserData = localStorage.getItem(`userData_${state.wallet.account}`);\n        console.log('checkRegistration: storedUserData =', storedUserData);\n        if (storedUserData) {\n          const userProfile: UserProfile = JSON.parse(storedUserData);\n          setState(prev => ({\n            ...prev,\n            isRegistered,\n            userProfile,\n          }));\n          console.log('checkRegistration: Loaded user profile:', userProfile);\n        } else {\n          setState(prev => ({\n            ...prev,\n            isRegistered,\n          }));\n        }\n      } else {\n        console.log('checkRegistration: User not registered, setting isRegistered to false');\n        setState(prev => ({\n          ...prev,\n          isRegistered: false,\n          userProfile: null,\n        }));\n      }\n\n      return isRegistered;\n    } catch (error) {\n      console.error('Error checking registration:', error);\n      return false;\n    }\n  }, [state.wallet.account]);\n\n  const disconnectWallet = useCallback(() => {\n    // Note: We don't clear localStorage here to preserve user data for future logins\n    setState({\n      wallet: {\n        isConnected: false,\n        account: null,\n        chainId: null,\n        balance: null,\n      },\n      userProfile: null,\n      isRegistered: false,\n      isLoading: false,\n      error: null,\n    });\n    setProvider(null);\n    setSigner(null);\n  }, []);\n\n  const connectWallet = useCallback(async () => {\n    if (!window.ethereum) {\n      setState(prev => ({\n        ...prev,\n        error: 'Please install MetaMask to use this application!'\n      }));\n      return;\n    }\n\n    try {\n      setState(prev => ({ ...prev, isLoading: true, error: null }));\n\n      // Request account access\n      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });\n      const account = accounts[0];\n\n      // Get the current network\n      const newProvider = new ethers.BrowserProvider(window.ethereum);\n      const network = await newProvider.getNetwork();\n      const balance = await newProvider.getBalance(account);\n      const newSigner = await newProvider.getSigner();\n\n      setProvider(newProvider);\n      setSigner(newSigner);\n\n      // Initialize encryption key for the user\n      initializeEncryptionKey(account);\n\n      // Update state\n      setState(prev => ({\n        ...prev,\n        wallet: {\n          isConnected: true,\n          account,\n          chainId: network.chainId.toString(),\n          balance: ethers.formatEther(balance)\n        },\n        isLoading: false\n      }));\n\n      // Check if user is registered\n      await checkRegistration();\n\n    } catch (error) {\n      console.error('Error connecting wallet:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Failed to connect wallet. Please try again.'\n      }));\n    }\n  }, [checkRegistration, initializeEncryptionKey]);\n\n  const handleAccountsChanged = useCallback((accounts: string[]) => {\n    if (accounts.length === 0) {\n      disconnectWallet();\n    } else {\n      connectWallet();\n    }\n  }, [connectWallet, disconnectWallet]);\n\n  const clearUserData = useCallback(() => {\n    if (state.wallet.account) {\n      localStorage.removeItem(`user_${state.wallet.account}`);\n      // Don't remove the encryption key or files on logout\n      // This allows users to access their files when they log back in\n    }\n    \n    setState(prev => ({\n      ...prev,\n      isRegistered: false,\n      userProfile: null,\n      error: null\n    }));\n  }, [state.wallet.account]);\n\n  const registerUser = useCallback(async (username: string, email: string): Promise<boolean> => {\n    console.log('registerUser called with:', { username, email, account: state.wallet.account });\n    \n    if (!provider || !signer || !state.wallet.account) {\n      console.error('registerUser: Wallet not connected', { provider: !!provider, signer: !!signer, account: state.wallet.account });\n      throw new Error('Wallet not connected');\n    }\n\n    try {\n      setState(prev => ({ ...prev, isLoading: true, error: null }));\n\n      const userProfile: UserProfile = {\n        username,\n        email,\n        walletAddress: state.wallet.account,\n        registrationTime: new Date().toISOString(),\n        isActive: true,\n        reputationScore: 0,\n        accessRoles: ['user']\n      };\n      \n      // Update state\n      setState(prev => ({\n        ...prev,\n        isRegistered: true,\n        userProfile,\n        isLoading: false,\n        error: null,\n      }));\n      \n      // Save to localStorage\n      localStorage.setItem(`user_${state.wallet.account}`, JSON.stringify(userProfile));\n      \n      // Generate and store encryption key if it doesn't exist\n      if (!localStorage.getItem(`encryption_key_${state.wallet.account}`)) {\n        const key = generateEncryptionKey();\n        localStorage.setItem(`encryption_key_${state.wallet.account}`, key);\n        \n        // In a real app, you would show this to the user and ask them to save it\n        alert(`IMPORTANT: Your encryption key is: ${key}\\n\\nPlease save this key in a secure place. You will need it to access your files.`);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Registration failed:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Failed to register user. Please try again.'\n      }));\n      return false;\n    }\n  }, [provider, signer, state.wallet.account]);\n\n  const value: WalletContextType = {\n    state,\n    connectWallet,\n    disconnectWallet,\n    checkRegistration,\n    registerUser,\n    clearUserData,\n    getEncryptionKey: getEncryptionKeyFromState,\n    getStoredFiles,\n    storeFile,\n    deleteStoredFile: deleteStoredFile as (fileId: string) => StoredFile[],\n    getEncryptionKeyFromState,\n  };\n\n  return (\n    <WalletContext.Provider value={value}>\n      {children}\n    </WalletContext.Provider>\n  );\n};\n\nexport const useWallet = (): WalletContextType => {\n  const context = useContext(WalletContext);\n  if (context === undefined) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\n// Extend Window interface for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}